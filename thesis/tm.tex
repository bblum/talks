\chapter{Transactions}
\label{chap:tm}

%\inspirationalquote{This paper presents earth-shaking work that deserves to be read by the entire computer science community.
%To that end, have you considered putting it in a thesis?}
%{Anonymous SIGBOVIK reviewer}

\inspirationalquote{
\begin{tabular}{p{0.47\textwidth}}
One can only build a sand castle where the sand is wet. \\
But where the sand is wet, the tide comes. \\
Yet we still build sand castles.
\end{tabular}}
{Yuri, Doki Doki Literature Club}


% notes to self abour marios tests
% counter: tests k threads on n iterations, benchmark xchg-aways vs txn. removed benchmarking, added assertion that no counts are lost.

% TODO

Transactional memory (TM) is a concurrency primitive
by which programmers may attempt an arbitrary sequence of shared memory accesses,
which will either be committed (made visible to other processors/threads) atomically,
such that no intermediate state modification is ever visible,
or in the case of a conflict which would prevent such,
discarded with an error code returned to allow the programmer to write a synchronized backup path.
%
Transactional memory specifications typically have three API functions, abstractly speaking:
\begin{itemize}
	\item  {\sf begin} begins a transaction,
		staging any subsequent shared memory accesses in some temporary thread-local storage,
		and checking for conflicts with the accesses of any other threads or CPUs.
		If the transaction is unsuccessful, as described below,
		{\sf begin} instead returns an error code
		indicating the programmer should fall back to some other, possibly slower, synchronization method.
	\item {\sf end} ends a transaction,
		attempting to commit all staged accesses to the shared memory atomically with respect to
		reads or writes from other concurrently-executing code.
		If any of those accesses conflict (i.e., read/write or write/write)
		with any other access to the same memory since the transaction started,
		they are instead discarded and execution state reverts to the {\sf begin} with an error code as described above.
	\item {\sf abort} explicitly aborts a transaction,
		regardless of any memory conflicts,
		discarding changes and reverting execution as described above.
		Some implementations allow an arbitrary abort code to be specified
		which will appear in {\sf begin}'s error code.
\end{itemize}

% do they track changes in pthread-style TLS? or?
{\bf Implementations.}
Software TM implementations (STM) typically function as a library,
tracking staged memory accesses in local memory,
and aborting whenever a conflict is detected between two transactions' tracked accesses \cite{stm-pldi06}.
Hardware TM implementations (HTM) use processor-level hardware support,
which stages changes in per-CPU cache lines,
and may abort for STM's reason above \cite{htm-experience},
or additionally whenever a conflict is detected between one transaction's traced access and {\em any} other memory access,
or whenever a conflict occurs on the same cache line, not necessarily the same address,
or in case of any system interrupt or cache overflow.

{\bf Terminology.}
The world of hardware transactional memory is home to several more confusing acronyms in addition to ``HTM''.
Transactional Synchronization Extensions (TSX)
refers to Intel's implementation of HTM on the Haswell microarchitecture
\cite{htm-haswell}.
Restricted Transactional Memory (RTM)
refers to the {\tt xbegin}, {\tt xend}, and {\tt xabort} subset of TSX instructions,
which of course correspond to {\sf begin}, {\tt end}, and {\tt abort} listed above,
and which GCC exposes as C/C++ intrinsices named {\tt \_xbegin()}, {\tt \_xend()}, and {\tt \_xabort()}
\cite{htm-gcc}.
Hardware Lock Elision (HLE)
refers to the {\tt xacquire} and {\tt xrelease} subset of TSX instructions,
which extend the traditional interface to offer a slightly higher-level way to access the CPU feature,
optimized for simplicity for locking-like synchronization patterns
% other possible things to cite here:
% https://lwn.net/Articles/534758/
% https://software.intel.com/en-us/node/683688
\cite{hardware-lock-elision}.
In this thesis I focus on RTM, the more general (i.e., expressive (i.e., bug-prone)) interface,
and among all these acronyms restrict myself to ``HTM''
(when referring to transactional memory as a concurrency primitive in the abstract)
and ``TSX''
(when referring to Intel's implementation and/or GCC's intrinsics interface).
The non-pedantic reader may treat these as interchangeable.

The example TSX program from Figure~\ref{fig:htm-example} (\sect{\ref{sec:overview-tm}})
is reproduced here for the reader's convenience.

\begin{figure}[h]
	\input{fig-htm-example}
	\caption{Example TSX program.}
	\label{fig:htm-example-reproduced}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Concurrency Model}
\label{sec:tm-design}

While up to now Landslide's tested programs' concurrency has been limited to timer-driven thread scheduling,
HTM presents a fundamentally new dimension of nondeterminism,
namely the hardware's ability to revert execution sequences
and the delayed visibility of changes to other threads.
In order to efficiently test HTM programs in Landslide,
in this section
I develop a simpler concurrency model and offer a proof of equivalence to HTM execution semantics.
I make two major simplifications:
simulating transaction aborts as immediate failure injections,
and treating transaction atomicity as a global mutex during data-race analysis;
and provide corresponding equivalence proofs.

{\bf Notation.} Let $I = TN_1@L_1, TN_2@L_2, ... TN_n@L_n$,
with $N_i$ a thread ID and $L_i$ a code line number,
denote the execution sequence of a program as it runs according to the specified thread interleaving.
This serialization of concurrent execution is told from the perspective of all CPUs at once
and hence assumes sequential consistency.
% TODO: fix sect refrance
For discussion of relaxed memory models refer to Section~\ref{sec:warpzone}.

\subsection{Example}

Consider again the program in Figure~\ref{fig:htm-example-reproduced}.
Note that the C-style {\tt x++} operations, when compiled into assembly, %\cite{printy},
results in multiple memory accesses which can be interleaved with other threads.
\[
\begin{tabular}{ll}
	$2a$ & \texttt{temp <- x;} \\
	$2b$ & \texttt{temp <- temp + 1;} \\
	$2c$ & \texttt{x <- temp;} \\
\end{tabular}
\]

% T1 T2 T3 but latex doesn't allow #s in cmd names
\newcommand\ti{\ensuremath{\hilight{lavender}{\mathbf{T1}}}\xspace}
\newcommand\tj{\ensuremath{\hilight{seafoam}{\mathbf{T2}}}\xspace}
\newcommand\tk{\ensuremath{\hilight{salmon}{\mathbf{T3}}}\xspace}

\newcommand\tiat[1]{\ensuremath{\hilight{lavender}{\mathbf{T1}@#1}}\xspace}
\newcommand\tjat[1]{\ensuremath{\hilight{seafoam}{\mathbf{T2}@#1}}\xspace}
\newcommand\tkat[1]{\ensuremath{\hilight{salmon}{\mathbf{T3}@#1}}\xspace}

If these instructions from the {\tt x++} in the transaction are preempted,
with another thread's access to {\tt x} interleaved in between,
the transaction will abort.
So, the interleaving
\[
	\tiat{1}, \tiat{2a}, \tiat{2b}, \tjat{1}, \tjat{2}, \tjat{3}, \tiat{2c}, \tiat{3}
\]
or, henceforth abbreviated for clarity:
\[
	\tiat{1-2b}, \tjat{1-3}, \tiat{2c-3}
\]
is not possible; rather, \ti will fall into the backup path:
\[
	\tiat{1-2b}, \tjat{1-3}, \tiat{4-7}
\]
However, the {\tt x++} operation from the failure path (correspondingly $6a$, $6b$, $6c$)
{\em can} be thusly separated with conflicting accesses interleaved in between,
since the mutex only protects the failure path against other failure paths,
but not against the transaction itself.
So (assuming {\tt x} is intended to be a precise counter rather than a sloppy one),
%losing one of the increments to which constitutes a bug),
the following interleaving exposes a bug:%
\footnote{Note also that this bug requires either at least 3 threads or at least 2 iterations between 2 threads to expose;
this highlights MC's dependence on its test cases to produce meaningful state spaces in the first place.}
\[
	\tiat{1-2b}, \tjat{1-3}, \tiat{4-6b}, \tkat{1-3}, \tiat{6c-7}
\]
Prior work \cite{htm-mario} proposed the idiom shown in Figure~\ref{fig:htm-fixed}
to exclude this family of interleavings,
which shows that correctly synchronizing even the simplest transactions may be surprisingly difficult or complex.
%further motivating our research.

\begin{figure}[t]
	\begin{center}
		\begin{tabular}{ll}
		%\texttt{void count() \{} \\
		%\texttt{~~~~for (int i = 0; i < 1000; i++) \{} \\
		& \texttt{\ctype{bool} prevent\_transactions = \const{false};} \\
		\\
		0 & \texttt{\flow{while} (prevent\_transactions) \flow{continue};} \\
		1 & \texttt{\flow{if} ((status = \call{\_xbegin}()) == \const{\_XBEGIN\_STARTED}) \{} \\
		2 & \texttt{~~~~\flow{if} (prevent\_transactions)} \\
		3 & \texttt{~~~~~~~~\call{\_xabort}();} \\
		4 & \texttt{~~~~x++;} \\
		5 & \texttt{~~~~\call{\_xend}();} \\
		6 & \texttt{\} \flow{else} \{} \\
		7 & \texttt{~~~~\call{mutex\_lock}(\&m);} \\
		8 & \texttt{~~~~prevent\_transactions = \const{true};} \\
		9 & \texttt{~~~~x++;} \\
		A & \texttt{~~~~prevent\_transactions = \const{false};} \\
		B & \texttt{~~~~\call{mutex\_unlock}(\&m);} \\
		C & \texttt{\}} \\
		%\texttt{~~~~\}} \\
		%\texttt{\}} \\
		\end{tabular}
	\end{center}
	\caption{Variant of the program in Figure~\ref{fig:htm-example-reproduced},
		with additional synchronization to protect the failure path from the transactional path.
		The optional line 0 serves to prevent a cascade of failure paths
		for the sake of performance
		by allowing threads to wait until transacting is safe again.}
	\label{fig:htm-fixed}
\end{figure}

\subsection{Modeling Transaction Failure}

In the previous section's examples,
the way I stated interleavings such as $\tiat{1-2c}, \tjat{1-3}, \tiat{4-7}$%
\footnote{For a clearer example here I have reordered \ti's write to {\tt x} before \tj's part, compared to before.}
glossed over the HTM execution semantics underlying how such a sequence of operations would be carried out.
For example, thread 1's write during $2c$ is not actually visible to thread 2,
such as it would be under a thread-scheduling-only concurrency model.

Intel's official TSX documentation summarizes its interface and behaviour in prose \cite{intel-tsx-overview};
to the best of my knowledge,
no formal definition exists which could be verified in a mechanized logical framework \cite{x86-semantics}.
Hence the proofs in this section will likewise be in prose.
To summarize HTM's execution semantics:

% TODO FIXME: this is not genral semantics, this is jut as epplies to the examineple. rephrase
\begin{enumerate}
	\item any modifications to shared state (such as $2c$) by \ti are not visible to \tj during its execution,
		despite \tj being executed afterwards, and
	\item all local and global state changes by \ti between lines $1$ and $2c$ are discarded when jumping to line $4$.
\end{enumerate}

% there shouldbe a better word than 'requires' here.. benefits from.. "the point of it is"..
While use of HTM in production requires the performance advantage
of temporarily staging such accesses in local CPU cache,
model checking such programs need be concerned only with the program's {\em observable} behaviours.
I claim that MCing the simpler interleaving $\tiat{1}, \tjat{1-3}, \tiat{4-7}$
is an equivalent verification as MCing the one above;
in fact, this interleaving suffices to check
all observable behaviours
of all interleavings
of all subsets of $\tjat{1-3}$
with all subsets of $\tiat{2a-2c}$,
whether they share a memory conflict or not.
Stated formally, let:

\newcommand\tii{\ensuremath{\hilight{lavender}{\mathbf{Ti}}}\xspace}
\newcommand\tjj{\ensuremath{\hilight{seafoam}{\mathbf{Tj}}}\xspace}
\newcommand\tkk{\ensuremath{\hilight{salmon}{\mathbf{Tk}}}\xspace}

\newcommand\tiiat[1]{\ensuremath{\hilight{lavender}{\mathbf{Ti}@#1}}\xspace}
\newcommand\tjjat[1]{\ensuremath{\hilight{seafoam} {\mathbf{Tj}@#1}}\xspace}
\newcommand\tkkat[1]{\ensuremath{\hilight{salmon}  {\mathbf{Tk}@#1}}\xspace}

\begin{itemize}
	\item $\tiiat{\alpha}$ be an HTM begin operation,
	\item $\tiiat{\beta_1}\dots\tiiat{\beta_n}$ be the transaction body (with $\beta_n$ the HTM end call),
	\item $\tiiat{\phi_1}\dots\tiiat{\phi_m}$ be the failure path, and
	\item $\tiiat{\omega_1}\dots\tiiat{\omega_l}$ be the subsequent code executed unconditionally.
\end{itemize}
Note that arbitrary code may not be structured to distinguish these as nicely as in our examples;
e.g., more code may exist in the success branch after {\tt \_xend()};
such would be considered part of $\omega$ here.

Then, without loss of generality (for any number of other threads \tjj/\tkk, and for any number of thread switches away from \tii during the transaction):
\vspace{1em}

\begin{lemma}[Equivalence of Aborts]
	\label{lem:equiv}
	For any interleaving prefix
	\[
	\begin{tabular}{c}
		$\tiiat{\alpha},\tiiat{\beta_1}\dots\tiiat{\beta_b},$\\
		$\tjjat{\gamma_1}\dots\tjjat{\gamma_j},$ \\
		$\tkkat{\kappa_1}\dots\tkkat{\kappa_k},$ \\
		$\tiiat{\beta_{b+1}}$ % $\dots\tiiat{\beta_{n-1}}$ -- excluded bc might abort
	\end{tabular}
	\]
	with $b<n$, $j \ne i$, $k \ne i$, etc., either:
	\begin{enumerate}
		\item $\tiiat{\alpha},\tjjat{\gamma_1}\dots\tjjat{\gamma_j},\tkkat{\kappa_1}\dots\tkkat{\kappa_k},\tiiat{\phi_1}\dots$
			(conflicting case), or
		\item $\tiiat{\alpha},\tiiat{\beta_1}\dots\tiiat{\beta_b}\dots\tiiat{\beta_n},\tjjat{\gamma_1}\dots\tjjat{\gamma_j},\tkkat{\kappa_1}\dots\tkkat{\kappa_k}$
			(independent case)
	\end{enumerate}
	exists and is observationally equivalent.
\end{lemma}

\begin{proof}
	Case on whether the operations by \tjj and/or \tkk have any memory conflicts (read/\allowbreak{}write or write/write)
	with $\tiiat{\beta_1}\dots\tiiat{\beta_n}$.
	If so, then the hardware will abort \tii's transaction, discarding the effects of $\tiiat{\beta_1}\dots\tiiat{\beta_n}$
	and jumping to $\tiiat{\phi_1}$,
	satisfying case 1.
	% TODO: give a secrion referenace
	Otherwise, by DPOR's definition of transition dependence \cite{dpor}, %,landslide-phdthesis},
	$\tiiat{\beta_{b+1}}\dots\tiiat{\beta_n}$ is independent with the transitions of \tjj and \tkk,
	may be successfully executed until transaction commit,
	and reordering them produces an equivalent interleaving,
	satisfying case 2.
\end{proof}

The claim's second part follows naturally.
\vspace{1em}

\begin{theorem}[Atomicity of Transactions]
	\label{thm:atom}
	For any state space $S$ of a transactionally-concurrent program,
	an equivalent state space exists in which all transactions are either executed atomically or aborted immediately.
\end{theorem}

\begin{proof}
	For every $I \in S$ with $\tiiat{\alpha},\tiiat{\beta_1}\dots\tiiat{\beta_b},$ $\tjjat{\dots},\tkkat{\dots},\tiiat{\beta_{b+1}} \in I$,
	apply Lemma~\ref{lem:equiv} to obtain an equivalent interleaving $I'$ satisfying the theorem condition.
	The resulting $S'$ can then be MCed without ever simulating HTM rollbacks.
\end{proof}

\subsection{Memory Access Analysis}

Next comes the issue of memory accesses within transactions with regard to data-race analysis (\sect{\ref{sec:background-datarace}}).
Theorem~\ref{thm:atom} provides that the body of all transactions may be executed atomically within the MC environment.
While they may interleave between other non-transactional sequences,
no other operations (whether transactional or not) will interrupt them.
I claim this level of atomicity is equivalent to that provided by a global lock,
and hence abstracting it as such in Landslide's data-race analysis is sound.

Let $\tiiat{\mu},\tjjat{\nu}$ be a pair of memory accesses to the same address, at least one a write,
in some transactional execution $I$ normalized under Lemma~\ref{lem:equiv}.
Then let $\mathsf{lockify}_m(\tkkat{L})$ denote a function over instructions in $I$,
which replaces $\tkkat{L}$ with $\tkkat{\mathsf{lock}(m)}$ if $L$ is a successful HTM begin,
with a no-op if $L$ is a transaction abort,
or with $\tkkat{\mathsf{unlock}(m)}$ if $L$ is an HTM end,
or no replacement otherwise.
Finally, let $I' = \exists m. \mathsf{lockify}_m(I)$,
the execution with the boundaries of all successful transactions replaced by an abstract global lock.
Lemma~\ref{lem:equiv} guarantees mutual exclusion of $m$.
\vspace{1em}

\begin{theorem}[Transactions are a Global Lock]
	$\tiiat{\mu},\tjjat{\nu}$ is a data race in $I$ iff it is a data race in $I'$.
\end{theorem}

\begin{proof}
I prove one case for each variant definiton for data races supported in Landslide \cite{quicksand}.
For each, I state below what it means to race in an execution with synchronizing HTM instructions.

\begin{itemize}
	\item {\bf Limited Happens-Before.}
		%Under this definition,
		To race in $I$ they must be reorderable at instruction granularity,
		at least one with a thread switch immediately before or after.
		\cite{tsan,hybriddatarace}.
		\begin{itemize}
			\llitem $I \Rightarrow I'$:
				If $\tiiat{\mu},\tjjat{\nu}$ race in $I$,
				then they cannot both be in successful transactions,
				or else placing \tiiat{\mu} within the boundaries of \tjjat{\nu}'s transaction
				would cause the latter to abort, invalidating \tjjat{\nu}, or vice versa.
				Hence they will not both hold $m$ in $I'$.
				Otherwise their lock-sets and DPOR dependence relation remain unchanged.
			\llitem $I' \Rightarrow I$:
				If $\tiiat{\mu},\tjjat{\nu}$ race in $I'$,
				both corresponding threads cannot hold $m$;
				WLOG let $\tii$ not hold $m$ during $\tiiat{\mu}$.
				Then in $I$, $\tiiat{\mu}$ is not in a transaction.
				With the remainder of their lock-sets still disjoint,
				and still not DPOR-dependent, $\tjjat{\nu}$ (or its containing transaction)
				can then be reordered directly before or after $\tiiat{\mu}$.
		\end{itemize}
	\item {\bf Pure Happens-Before.}
		WLOG fix $\tiiat{\mu} \prec \tjjat{\nu} \in I$.
		Then to race in $I$ there must be no pair of synchronizing instructions
		$\tiiat{\epsilon}$ (a release edge) and $\tjjat{\chi}$ (an acquire edge) such that
		\[
			\tiiat{\mu} \prec \tiiat{\epsilon} \prec \tjjat{\chi} \prec \tjjat{\nu} \in I
		\]
		to update the vector clock epoch between \tiiat{\mu} and \tjjat{\nu} \cite{djit,fasttrack}.
		\begin{itemize}
			\llitem $I \Rightarrow I'$:
				If $\tiiat{\mu},\tjjat{\nu}$ race in $I$,
				then they cannot both be in successful transactions,
				or else Lemma~\ref{lem:equiv} normalization would provide
				the corresponding HTM end and begin for $\tiiat{\epsilon}$ and $\tjjat{\chi}$ respectively.
				Hence there will be no unlock/lock pair on $m$ in $I'$ to satisfy the above sequence.
			\llitem $I' \Rightarrow I$:
				If $\tiiat{\mu},\tjjat{\nu}$ race in $I'$,
				then they cannot both hold $m$,
				or else $\mathsf{lockify}_m$ would provide the corresponding
				unlock and lock for $\tiiat{\epsilon}$ and $\tjjat{\chi}$ respectively.
				Hence there will be no HTM end/begin pair in $I$ to satisfy the above sequence.
		\end{itemize}
		%In both cases $I$ and $I'$ otherwise have the same synchronizing instructions.
\end{itemize}
Hence, data-race analysis is sound when transaction boundaries are replaced by an abstract global lock.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation}

% TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Evaluation}

% TODO

