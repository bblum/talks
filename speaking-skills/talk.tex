\documentclass[xcolor=dvipsnames]{beamer}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

\usepackage{manfnt}
\usepackage{wasysym}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{url}
\usepackage{ulem}
\usepackage{marvosym}
\usepackage{skull}
\usepackage{proof}
\usepackage{array}
\setbeamertemplate{navigation symbols}{}

\title[Landslide]{{\bf Coping with Exponential Explosion in Systematic Testing}}
%\subtitle[]{ {\em more clever than } ``\texttt{slaughter cho2}'' {\em since 2011.}}
\author[Ben Blum]{Ben Blum \texttt{(bblum@andrew.cmu.edu)}}

\institute[CMU]{Carnegie Mellon University}
\date[]{2014, June 4}

\setbeamertemplate{footline}{\hspace*{.5cm}\scriptsize{\insertauthor\hspace*{50pt} \hfill\insertframenumber\hspace*{.5cm}}} 

\usecolortheme{seahorse}
\usecolortheme{rose}
\useoutertheme{infolines}

\usecolortheme[named=ForestGreen]{structure}

\newcommand\noob{\mathsf{noob}}
\newcommand\gibs{\mathsf{gibs}}
\newcommand\dps{\mathsf{dps}}
\newcommand\squig\rightsquigarrow
\newcommand\Coloneqq{\mathrel{\mathop{::}}=}
\newcommand\dmg{\text{\Laserbeam}}
\newcommand\delter\delta
\newcommand\alpher\alpha
\newcommand\defnor{\text{ }|\text{ }}

\newcommand\pimp{\mathop{\supset}}
\newcommand\pand{\mathop{\wedge}}
\newcommand\por{\mathop{\vee}}
\newcommand\ptrue{\top}
\newcommand\pfalse{\bot}


\begin{document}
\normalem
\begin{frame}
	\titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\linegap{\vspace{0.2in}}
\newcommand\breakslide[1]{\begin{frame}{} \begin{center} {\Large #1} \end{center} \end{frame}}

\section{Introduction}

% Before intro outline slide, say about this talk words

\subsection{Introduction}

\begin{frame}{Outline}
	\textbf{Intro to Systematic Testing}
	\begin{itemize}
		\item Stress testing vs systematic testing
		\item Preemption points and state spaces
	\end{itemize}
	{\bf Coping with Exponential Explosion}
	\begin{itemize}
		\item State space reduction
		\item State space estimation
		\item Iterative context bounding
			% say: survey of the state of the art
	\end{itemize}
	{\bf Landslide}
	\begin{itemize}
		\item Design (briefly) % say: overview
		\item Successes and limitations in 15-410
		\item Automatic preemption points
		% Say: A new technique I've been working on to overcome one of systematic testing's inherent weaknesses that can hopefully make Landslide accessible to a wider range of 15-410 students.
	\end{itemize}
	{\bf Conclusion}
\end{frame}

\newcommand\related[1]{\textsuperscript{\em [#1]}}

%%%%%%%%%%%%%% notes on sections / slides %%%%%%%%%%%%%%%%%%%%%%
\newcommand\dontcompilethis[1]{}
\dontcompilethis{
\begin{frame}{Outline}
	\textbf{Intro to Systematic Testing}
	\begin{itemize}
		\item Stress testing % moving past stress testing
		\item Preemption points
		\item Systematic testing vs stress testing
	\end{itemize}
	{\bf Landslide}
	\begin{itemize}
		\item Overview
		\item How it works (briefly)
		\item Successes and limitations 15-410
	\end{itemize}
	{\bf Coping with Exponential Explosion}
	\begin{itemize}
		% TODO: make sure to have an intro-to-this-section slide
		\item State space reduction % DPOR, Parrot
		\item Exploration ordering % ICB
		\item State space estimation % estimates
	\end{itemize}
	{\bf Iterative Deepening}
	% say: I want to combine ideas from each of these 3 areas ...
	\begin{itemize}
		\item Motivation
		% say: Through all this, stress testing still has one advantage over
		%      systematic testing. You can kick off a stress test repeatedly running
		%      a particular test program, saying "I'll be back in 24 hours, try to get
		%      as much done as possible by then, ok?". Systematic testing makes you
		%      worry about choosing 'good' preemption points, and guess how many
		%      preemption points you can afford with a given CPU budget.
		%      HOW CAN WE DO THIS WHILE KEEPING THE ADVANTAGES (intelligent
		%      preemptions & exhaustiveness guarantees) ???? ? ? ?? ??
		\item Iterative deepening in chess
		\item Iterative deepening in Landslide
		\item Heuristic preemption points % mutex un/lock, data races, mov esp, priorities, etc
		\item What this means for 15-410
	\end{itemize}
	{\bf Conclusion}
\end{frame}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Systematic Testing}

\breakslide{What is Systematic Testing?}

\begin{frame}[fragile]{Case Study}
	\begin{center}
	\begin{verbatim}
	    int thread_fork()
	    {
	        thread_t *child = construct_new_thread();
	        add_to_runqueue(child);
	        return child->tid;
	    }
	\end{verbatim}
	\end{center}
	\pause

	\begin{itemize}
		\item On vanish, child's TCB is freed
		\item Forking thread does use-after-free
		\item Might return garbage instead of TID
	\end{itemize}
\end{frame}

\begin{frame}{Case Study - ``Good'' Interleaving}
	\begin{tabular}{|l|l|l}
		\cline{1-2}
		{\bf Thread 1} & {\bf Thread 2} & \\
		\cline{1-2}
		\texttt{spawn\_new\_thread} && \\
		\cline{1-2}
		\texttt{add\_to\_runqueue} && (new thread) \\
		\cline{1-2}
		\texttt{return child->tid} && (yield to child) \\
		\cline{1-2}
		& \texttt{vanish} & \\
		\cline{1-2}
		& (TCB gets freed) & \\
		\cline{1-2}
	\end{tabular}
\end{frame}

\begin{frame}{Case Study - Buggy Interleaving}
	\begin{tabular}{|l|l|l}
		\cline{1-2}
		{\bf Thread 1} & {\bf Thread 2} & \\
		\cline{1-2}
		\texttt{spawn\_new\_thread} && \\
		\cline{1-2}
		\texttt{add\_to\_runqueue} && (new thread + preempted) \\
		\cline{1-2}
		& \texttt{vanish} & \\
		\cline{1-2}
		& (TCB gets freed) & (yield to parent) \\
		\cline{1-2}
		\texttt{return child->tid} && (bad!) \\
		\cline{1-2}
	\end{tabular}
\end{frame}

% Say: In 15-410 we teach students to think about thread interleavings and race conditions using these 'tabular' execution traces. But to think about the state space in a way compatible with systematic testing, we'll need to move beyond them...

\begin{frame}{Moving Beyond Stress Testing}
	\textbf{Stress testing}
	\begin{itemize}
		\item Exercise as many interleavings as possible (given some CPU budget)
		\item Relies on randomly-occurring timer interrupts
		\item Exposes race conditions unreliably
		\begin{itemize}
			\item ``If a preemption occurs at just the right time\ldots''
		\end{itemize}
	\end{itemize}
	\pause
	\linegap

	{\bf Systematic Testing}\related{Godefroid '97}
	\begin{itemize}
		\item Exhaustively exercise {\em all} thread interleavings
		\begin{itemize}
			\item ...in terms of certain interesting ``preemption points''
		\end{itemize}
		\item Offers more reliable coverage and better reproducibility
	\end{itemize}
\end{frame}
		%\item Disadvantage: Relationship between number of preemption points is unpredictable

\begin{frame}{Preemption Points}
	Intuitively: Program locations where being preempted might cause different behaviour
	% i.e., "being preempted ... causing a different thread to run"
	\linegap

	Example preemption points:
	\begin{itemize}
		\item Every instruction (exhaustive, but intractable)
		\item Pthread library calls\related{Simsa '10}
		\item Kernel mutex/scheduler interface calls\related{Blum '12}
		\item Unprotected shared memory accesses % say: data races
		%\item A new thread becomes runnable
		%\item Voluntary reschedule (e.g. \texttt{yield}, \texttt{cond\_wait})
		%\item Synchronization primitives
	\end{itemize}
	\pause
	\linegap

	% Say "Let's see what our example program's state space looks like if we use X, Y, and Z PPs."
	For our case study, ``new thread becomes runnable'' \& ``thread vanishes'' are relevant.
\end{frame}

\begin{frame}{Case Study - Execution Tree}
	\begin{center}
		\includegraphics[width=0.9\textwidth]{threadfork0.png}
	\end{center}
\end{frame}
\begin{frame}{Case Study - Execution Tree}
	\begin{center}
		\includegraphics[width=0.9\textwidth]{threadfork05.png}
	\end{center}
\end{frame}
\begin{frame}{Case Study - Execution Tree}
	\begin{center}
		\includegraphics[width=0.9\textwidth]{threadfork1.png}
	\end{center}
\end{frame}
\begin{frame}{Case Study - Execution Tree}
	\begin{center}
		\includegraphics[width=0.9\textwidth]{threadfork2.png}
	\end{center}
\end{frame}
% FIXME: Want to have systematic testing definition slide after this? i guess?
% Say: "Systematic testing simply means forcing the program to execute each branch of this tree in sequence (and looking for bugs in each one)."


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Exponential Explosion}

\breakslide{How does systematic testing scale with more preemption points?}

\breakslide{\includegraphics[width=0.40\textwidth]{exponential-curve.pdf}}

\begin{frame}{State Space Reduction}
	Dynamic Partial Order Reduction\related{Flanagan '05}
	\begin{itemize}
		\item Identifies and prunes equivalent interleavings
		\item Requires knowledge of shared memory accesses between threads
		\item Requires depth-first search of execution tree
	\end{itemize}

	% TODO: put DPOR gr4fix here

	%Stable Multithreading\related{Cui '13}
	%\begin{itemize}
	%\end{itemize}
\end{frame}

\begin{frame}{State Space Estimation}
	Runtime estimation\related{Simsa '12} can guess state space size in advance
	\begin{itemize}
		\item Uses known branches as heuristic to guess total tree size
			% say: something more lucid :(
		\item Estimate improves as more state space is explored
		\item Allows user to guess whether completion is feasible
	\end{itemize}

	% TODO: gr4fix
\end{frame}

%\begin{frame}{Iterative Context Bounding\related{Musuvathi 07}}
%	Insight: Most bugs can be exposed with very few preemptions.
%	% say: presenting this specific one because it's most similar to
%	\begin{itemize}
%		\item Explore branches with fewer preemptions first.
%		\item More likely to find bugs sooner, if they exist
%		\item Just as likely to fail to complete too-large state spaces
%	\end{itemize}
%
%	% gr4fix
%\end{frame}

\begin{frame}{Remaining Challenges}
	State-of-the-art systematic testing can {\em mitigate} exponential explosion.
	%\begin{itemize}
	%	\item Reduce testing time exponentially by pruning redundant branches
	%	\item Inform users of total expected testing time
	%		% say: so they can manage testing resources
	%		% by only running tests that are more likely to complete
	%\end{itemize}
	%but still cannot:
	%\begin{itemize}
	%	\item Control total testing time to fit in a given time budget
	%	%\item Automatically decide which preemption points are valuable
	%		% haha-never
	%\end{itemize}
	\linegap

	However...
	\begin{itemize}
		\item With too many preemption points, it still fails
		\item Which PPs are ``good'' differs for each test case.
		\item Relationship between PPs and testing time is unpredictable.
	\end{itemize}

	% Say: "In the next section I'll talk about my experience working with students who could potentially benefit from systematic testing, which motivates the need for an automated solution to preemption points.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Landslide}

\breakslide{Landslide}

\begin{frame}{Overview}
	Landslide: A systematic testing tool for 15-410 Pebbles projects
	\linegap

	15-410: Operating System Design and Implementation
	\begin{itemize}
		\item Pebbles: a small UNIX-like kernel specification
		\item Students implement a userspace thread library and a kernel
		\item Both projects done in 2-person teams
		\item Simics, an x86 simulator, aids development/debugging
	\end{itemize}
	\pause
	\linegap

	Project history
	\begin{itemize}
		\item Began as 5th-year MS project with Garth Gibson, Jiri Simsa
		\item Tested Pebbles kernels, with user-provided annotations
		\item Recently, fully-automatic instrumentation for thread libraries
	\end{itemize}
\end{frame}

\begin{frame}{Landslide Design}
	As a Simics module, Landslide knows:
	\begin{itemize}
		\item Every instruction executed
			% say: useful for modeling the kernel/thrlib's behaviour
		\item Every memory address read/written
			% say: useful for checking memory/heap errors
	\end{itemize}
	\pause
	\linegap

	Navigating the state space
	\begin{itemize}
		\item At each preemption point:
		\begin{itemize}
			\item Injects timer interrupts to control thread scheduling
		\end{itemize}
		\item At end of each iteration (i.e., each interleaving pattern):
		\begin{itemize}
			\item Uses Simics bookmarks (reverse-execution) to rewind machine state
		\end{itemize}
	\end{itemize}
	\pause
	\linegap

	Identifying bugs
	\begin{itemize}
		\item False-negative-oriented approach % say: "that is, it doesn't flag suspicious behaviours, only behaviours like crashes / segfaults that are obviously wrong"
		\item Assertion failure, use-after-free, deadlock, memory leak, infinite loop
	\end{itemize}
\end{frame}

% TODO: picture of landslide internals here

% TODO: picture of foundabug here

\begin{frame}{Experience}
	15-410 student user studies
	\begin{itemize}
		\item Recruited students to volunteer near end of kernel project
		\item Provided advice to help annotation, but not to help debug
		\item Majority of groups found previously-unknown races
	\end{itemize}
	\pause
	\linegap

	Limitations
	\begin{itemize}
		\item Students spent \textasciitilde{}2 hours annotating kernels
		\item After annotation, 30-60 min configuring preemption points
			% say: ...before finding & analyzing bugs
		\item Selection bias: only students with free time volunteered
	\end{itemize}
	% Say: reducing annotation effort is just engineering, but the need for
	% the tool to automatically infer & insert "good" preemption points
	% motivates my new technique [of iterative deepening].
\end{frame}

% TODO: iterative deepening

% TODO: conclusion

% TODO: POST-PRACTICE bonus slide for CHESS ICB
% TODO: POST-PRACTICE bonus slide for THIS IS WHAT THE REFRANCE


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: all below this is old
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\dontcompilethis{

\section{Systematic Testing}

\breakslide{\Large Systematic Testing}


% TODO: find a home for this in 'coping' section
\begin{frame}{Preemption Point Tradeoffs}
	Important point: What does ``all possible interleavings'' mean?

	\linegap
	One extreme: Decide at every instruction
	\begin{itemize}
		\item {\em Good news}: Will find every possible race condition.
		\item {\em Bad news}: Runtime of test will be impossibly large.
	\end{itemize}
	\linegap

	Other extreme: Nothing is a decision point
	\begin{itemize}
		\item {\em Good news}: Test will finish quickly.
		\item {\em Bad news}: Only one execution was checked for bugginess.
		\item {\em Bad news}: No alternative interleavings explored.
		\begin{itemize}
			\item Makes ``no race found'' a weak claim.
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{More on Decision Points}
	Sweet spot: Insert a thread switch everywhere it ``might matter''.

	\linegap
	When do we fear being preempted?
	\begin{itemize}
		\item New threads becoming runnable (\texttt{fork}, \texttt{cond\_signal}, etc)
			\begin{itemize}
				\item Preemptions may cause it to run before we're ready
			\end{itemize}
		\item Synchronization primitives (\texttt{mutex\_lock}, etc)
			\begin{itemize}
				\item If used improperly\ldots
			\end{itemize}
		\item Unprotected shared memory accesses % Say: more on this later.
			\begin{itemize}
				\item May result in data structure corruption
			\end{itemize}
	\end{itemize}
	\linegap

	Finding the sweet spot is a joint effort between programmer and tool. (More on this later.)
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{State Space Explosion}

\begin{frame}{State Space Explosion}
	State spaces grow exponentially
	\begin{itemize}
		\item With $d$ decision points, $k$ runnable threads, size $d^k$.
		\item Threatens our ability to explore everything.
		\item Fortunately, some sequences result in identical states.
	\end{itemize}
	\linegap

	{\bf Partial Order Reduction} can help.
	\begin{itemize}
		\item Complicated algorithm; ask me later for details.
		\item Intuitive explanation follows.
	\end{itemize}
\end{frame}

\begin{frame}{State Space Explosion}
	\begin{center}
	\includegraphics[width=\textwidth]{undiamond0.png}
	\end{center}
\end{frame}
\begin{frame}{State Space Explosion}
	\begin{center}
	\includegraphics[width=\textwidth]{undiamond1.png}
	\end{center}
\end{frame}
\begin{frame}{State Space Explosion}
	\begin{center}
	\includegraphics[width=\textwidth]{diamond1.png}
	\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Landslide}

\breakslide{\Huge Landslide}

\begin{frame}{About The Project}
	% 5th year MS since June 2011 % Say: planning to finish this may, hopefully
	My MS thesis project (June 2011-2012)
	\begin{itemize}
		\item Blum 2012 (CMU-CS-12-118) -- \url{http://bblum.net/thesis.pdf}
	\end{itemize}

	\linegap
	Now I'm a Ph.D. student\dots

	\linegap
	Working with Garth Gibson, Jiri Simsa

	\linegap
	{\bf Landslide}: Shows that your Pebbles are not as stable as you thought.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{How Landslide Works}

\begin{frame}{Anatomy}
	\begin{center}
	\includegraphics[width=0.6\textwidth]{landslide.png}
	\end{center}
\end{frame}

\begin{frame}{Identifying Bugs}
	Landslide can {\em definitely discover}:
	\begin{itemize}
		\item Kernel panics % Say: note: the better your asserts are..!
		\item Deadlock
		\item Use-after-free / double-free
	\end{itemize}
	\linegap
	Landslide can {\em reasonably suspect}:
	\begin{itemize}
		\item Memory leak
		\item Infinite loop (halting problem)
	\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Using Landslide}

\breakslide{\Large Using Landslide}

\begin{frame}{In Which Ben Offers Help}
	% Say: So, this wasn't just a research talk
	This is something you can try!
	\linegap

	Mutual benefit
	\begin{itemize}
		\item Landslide may help you find bugs
		\item You help Ben evaluate his research
	\end{itemize}
\end{frame}

\begin{frame}{Keeping It Real}
	Finding race conditions is hard for humans.

	\linegap
	It is hard for computer programs too.

	\linegap
	Landslide is not an oracle.
\end{frame}

\begin{frame}{Annotating Your Kernel}
	Step 1
	\begin{center}
		\includegraphics[width=0.9\textwidth]{tell_landslide.png}
	\end{center}
	Your kernel needs to say when certain events happen:
	\begin{itemize}
		\item When do threads become runnable / descheduled?
		\item When does the scheduler switch threads?
	\end{itemize}
\end{frame}

\begin{frame}{Configuring Landslide}
	Step 2
	\begin{center}
		\includegraphics[width=0.8\textwidth]{config-landslide.png}
	\end{center}
	Edit \texttt{config.landslide} with some details and tweaks

	Fill in two implementation-dependent C functions in Landslide ($\le$10 lines)
	% Say: Which depend on your kernel's specific implementation
\end{frame}

\begin{frame}{Configuring Decision Points}
	Landslide automatically identifies a minimal set of decision points.
	\begin{itemize}
		\item It might find bugs.
		\item It might overlook more fine-grained interleavings.
	\end{itemize}
	\linegap
	With help from you, it could find more.
	\begin{itemize}
		\item Optional annotation: \texttt{tell\_landslide\_decide()}
		\item Hints to where a context switch should be forced.
		\item Inside every call to \texttt{mutex\_lock}\ldots
	\end{itemize}
\end{frame}

\begin{frame}{And Hopefully\dots}
	\begin{center}
		\includegraphics[width=\textwidth]{found_a_bug.png}
	\end{center}
\end{frame}

\breakslide{\Large Quick Demo}

% TODO more of these with screenshots

%\begin{frame}{Decision Points (noticing a theme here?)}
%	Landslide is {\bf false negative}-oriented.
%	\begin{itemize}
%		\item If Landslide reports a bug, there is a bug for sure.
%			% Say: Well, except progress sense might be wrong.
%		\item If not,
%			\begin{itemize}
%				\item Maybe there was no race, or
%				\item Maybe your decision points were not granular enough.
%			\end{itemize}
%	\end{itemize}
%\end{frame}
%\begin{frame}{Decision Points (noticing a theme here?)}
%	Sometimes the default set will work.
%
%	Sometimes you need to tweak\ldots
%	\begin{itemize}
%		\item Ignore certain global mutexes
%		\item Whitelist or blacklist entire syscalls
%		\item (get creative)
%	\end{itemize}
%	Intuitively: focusing Landslide on relevant parts of the kernel.
%\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{User Study}

\begin{frame}{Last Year's Results}
	\begin{itemize}
		\item Worked with 5 groups
		\begin{itemize}
			\item \dots{}of which 4 put in enough time to make Landslide work
		\end{itemize}
		\linegap
		\item {\bf Investment}: about 2 to 3 hours
		\begin{itemize}
			\item Average 112 minutes doing required instrumentation
			\item Average 35 minutes configuring extra decision points \& interpreting ``found a bug'' output
		\end{itemize}
		\pause
		\linegap
		\item {\bf Return}: All 4 groups found bugs in their kernels.
		\begin{itemize}
			\item All groups found deterministic bugs (e.g., use-after-free)
			\item 2 groups found race conditions (i.e., Landslide needed to backtrack)
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{In Which Ben Offers Help - Warning}
	\textbf{If you are already struggling, this will not ``save'' you.}
	\begin{itemize}
		\item False-negatives: not guaranteed to find races at all
		\item Research-quality: possibly difficult to integrate with your kernel
		\item Finishing the kernel project is more important.
	\end{itemize}
	\pause
	\linegap
	This is for you if:
	\begin{itemize}
		%\item Be expecting an A or a B
		\item You have already submitted
		\item You are using late days, but willing to work over Carnival
		%\item Be able to turn in without late days (if you really had to)
		\item You are taking p3extra, but you already pass the hurdle
		\item You are looking for\ldots
			\begin{itemize}
				\item That ``one pesky race''
				\item A race that stress-testing missed
				\item Or just familiarity with a new technique
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{In Which Ben Offers Help}
	Your kernel
	\begin{itemize}
		\item Must load the shell and run programs
		\item \texttt{fork},
			\texttt{exec},
			\texttt{vanish},
			\texttt{wait},
			\texttt{readline}
		\item Must never spin-wait (see hurdle form!)
		\item Should \texttt{assert()} important invariants
		\begin{itemize}
			\item Think of \texttt{panic()} as \texttt{tell\_landslide\_bug()}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{In Which Ben Offers Help}
	User study this week, by appointment (\texttt{bblum@cs.cmu.edu})

	\linegap
	Expect to spend:
	\begin{itemize}
		\item Up to 3 hours, just to try it out.
		\item 4-6 hours, if you find a bug and track it down.
		\item More, for multiple bugs or the truly dedicated\ldots
	\end{itemize}
	\linegap

	Give feedback (intuitive? frustrating? found bugs?)

	\linegap
	{\bf Watch \texttt{410.announce} for details!}
\end{frame}

\subsection{End}
\breakslide{\Large Questions?}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% \section{Conclusion}
% \subsection{Conclusion}
% 
% \begin{frame}{Summary}
% 	\begin{itemize}
% 		\item
% 	\end{itemize}
% \end{frame}

\end{document}
%\begin{frame}{Partial Order Reduction}
%	\begin{center}
%	The next 6 slides won't be on the exam.
%
%		\Huge \dbend
%	\end{center}
%\end{frame}
%
%\begin{frame}{Partial Order Reduction}
%	A {\bf transition} is\ldots
%	\begin{itemize}
%		\item The sequence of instructions executed between choice points.
%	\end{itemize}
%	To express concurrency between transitions:
%	% Say: As a prerequisite for this algorithm, we need to build two sets to express the concurrency relations between the transitions
%	\begin{itemize}
%		\item Independence relation
%		\item Happens-before relation
%	\end{itemize}
%	% Say: This is hard, and I don't expect you to understand it during this lecture; you won't be tested on it or anything. My goal in presenting it is to convey how intensely cool the algorithm is, and hopefully you will keep thinking about it later. I'd be happy to answer questions about it later.
%\end{frame}
%
%\begin{frame}[fragile]{Partial Order Reduction - Independence Relation}
%	\begin{columns}[l]
%		\column{0.5\textwidth}
%		\begin{center}
%		\begin{verbatim}
%		void thread_A() {
%		    foo = 42;
%		}
%		void thread_B() {
%		    if (bar == 1337)
%		        print "Hello"
%		}
%		\end{verbatim}
%		\end{center}
%		\linegap
%
%		$A$ and $B$ are {\bf independent}.
%		\column{0.5\textwidth}
%		\begin{center}
%		\begin{verbatim}
%		void thread_A() {
%		    foo = 42;
%		}
%		void thread_C() {
%		    if (foo == 1337)
%		        print "Hello"
%		}
%		\end{verbatim}
%		\end{center}
%		\linegap
%
%		$A$ and $C$ {\bf conflict}.
%	\end{columns}
%\end{frame}
%
%\begin{frame}{Partial Order Reduction - Independence Relation}
%	Consider a trace of all shared memory reads/writes
%
%	\linegap
%	Two transitions (instruction sequences) $A$ and $B$ are independent iff:
%	\begin{itemize}
%		\item $Writes(A) \cap Writes(B) = \emptyset$
%		\item $Writes(A) \cap Reads(B) = \emptyset$
%		\item $Reads(A) \cap Writes(B) = \emptyset$
%	\end{itemize}
%\end{frame}
%
%\begin{frame}{Partial Order Reduction - Happens-before Relation}
%	\begin{columns}[l]
%		\column{0.5\textwidth}
%		\includegraphics[width=\textwidth]{hb.png}
%		\column{0.5\textwidth}
%		Is a transition ``enabled'' by a previous one?
%		\begin{itemize}
%			\item $A$ enables $B$
%			\item $B$ enables $C$ (same thread)
%			\item $B$ enables $D$
%		\end{itemize}
%%		Transitive closure
%%		\begin{itemize}
%%			\item $HB^* = \{AB, AC, AD, BC, BD\}$
%%		\end{itemize}
%		$C$ and $D$ are {\bf concurrent}!
%	\end{columns}
%\end{frame}
%
%\begin{frame}{Partial Order Reduction - Tagging}
%	Run POR at the end of each branch
%	\begin{itemize}
%		\item Identify which branches to explore next
%		\item Tag only a subset of all branches (hopefully)
%	\end{itemize}
%\end{frame}
%
%\begin{frame}{Partial Order Reduction - Tagging}
%	For each transition $T$, find an {\bf evil ancestor} $E$:
%	\begin{itemize}
%		\item $E$ and $T$ are concurrent.
%		\item $E$ and $T$ are not independent.
%		\item Intuitively: $T$ and $E$ could be reordered, and might behave differently.
%	\end{itemize}
%	Find a {\bf good sibling} $G$ of $E$:
%	\begin{itemize}
%		\item $G$ is the same thread as $T$
%		% Say: (if no such sibling, all siblings)
%		\item Intuitively: Find a branch in which $T$ runs before $E$.
%	\end{itemize}
%	Explore tagged branches depth-first.
%\end{frame}
%
%\begin{frame}{Partial Order Reduction}
%	\begin{center}
%		{\Huge \dbend}
%		\linegap
%		\linegap
%		\linegap
%
%		Feel free to ask me about this later.
%	\end{center}
%\end{frame}

% TODO: run through an example

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsection{Other Dynamic Techniques}
%
%\begin{frame}{Heuristic-Based Searching}
%	% Say: Note that this is beyond the scope of my personal project.
%	Maybe the tree is too big to search anyway?
%
%	\linegap
%	Search {\em most likely} branches first.
%	\begin{itemize}
%		\item ``Iterative Context Bounding''
%		\footnote{Microsoft Research - CHESS - Musuvathi et al.}
%		\begin{itemize}
%			\item Insight: Races tend to show up with few forced context switches.
%			\item Search branches with fewer preemptions first.
%		\end{itemize}
%		\item Find behaviours that are typical of buggy software.
%		\footnote{Stanford University - Dawson Engler}
%		\begin{itemize}
%			\item Different behaviour in different branches.
%				% Say: different all the time: no. different rarely: yes.
%			\item Use suspicious memory accesses as future choice points.
%		\end{itemize}
%	\end{itemize}
%	\linegap
%	Open research field, possibly my future work.
%\end{frame}
%
%% Say: I'm going to take a break from talking about systematic exploration to talk about other types of dynamic race detection - FIXME: if these slides fit in 60min.
%\begin{frame}{Data Race Detection}
%	Requires happens-before set and ``lock set''
%	\linegap
%
%	Two memory accesses $m_1$ and $m_2$ are a data race iff:
%	\begin{itemize}
%		\item Read/write or write/write to the same address, and
%		\item $(m_1,m_2) \not\in HB$, and
%		\item $Lock(m_1) \cap Lock(m_2) = \emptyset$
%	\end{itemize}
%\end{frame}
%\begin{frame}{Data Race Detection}
%	Data race detection vs systematic exploration
%	\begin{itemize}
%		\item More false positives
%			\begin{itemize}
%				\item (but still good style-checking!)
%			\end{itemize}
%		\item No false negatives
%		\item Still unable to find some types of bugs
%	\end{itemize}
%	\linegap
%	Hybrid approach? (future research)
%\end{frame}


