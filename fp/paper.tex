\documentclass{article}
\usepackage{lmodern}
\usepackage[charter]{mathdesign}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

\usepackage{caption,subcaption}
\usepackage{fullpage}
\usepackage{color}
\usepackage{manfnt}
\usepackage{wasysym}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{url}
%\usepackage{ulem}
\usepackage{marvosym}
%\usepackage{skull}
\usepackage{proof}
\usepackage{wrapfig}
\usepackage{array}

\title{{\bf Systematic Testing of Concurrent C0 with Landslide}}
\author{Ben Blum \\ \texttt{bblum@cs.cmu.edu}
	\and Frank Pfenning \\ \texttt{fp@cs.cmu.edu}
	\and Garth Gibson \\ \texttt{garth@cs.cmu.edu}}

\date{\today}

\newcommand\noob{\mathsf{noob}}
\newcommand\gibs{\mathsf{gibs}}
\newcommand\dps{\mathsf{dps}}
\newcommand\squig\rightsquigarrow
\newcommand\Coloneqq{\mathrel{\mathop{::}}=}
\newcommand\dmg{\text{\Laserbeam}}
\newcommand\delter\delta
\newcommand\alpher\alpha
\newcommand\defnor{\text{ }|\text{ }}

\newcommand\pimp{\mathop{\supset}}
\newcommand\pand{\mathop{\wedge}}
\newcommand\por{\mathop{\vee}}
\newcommand\ptrue{\top}
\newcommand\pfalse{\bot}


\begin{document}
\maketitle

\begin{abstract}
We have recently extended Landslide, our systematic testing platform originally for kernels, with some support for userspace testing. While the primary focus of this support is to test student thread library implementations, it can also test userspace apps built on top of those thread libraries. In this tech report we describe our experience using Landslide to test Concurrent C0, a type-safe educational language with a concurrent message-passing implementation in its runtime libraries.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}

We assume the reader will be familiar with the background in {\em systematic testing} \cite{verisoft}, the concurrency testing technique upon which Landslide is built.
Examples of state-of-the-art systematic testing tools from prior work include dBug \cite{dbug-ssv,dbug-retreat,parrot}, CHESS \cite{chess}, MoDist \cite{modist}, and MaceMC \cite{macemc}.

The primary state-space reduction technique for systematic testing is {\em dynamic partial order reduction} (DPOR) \cite{dpor}, various enhancements of which have been proposed in \cite{distributed-dpor,sdpor,parallel-dpor,bpor,optimal-dpor}.
Alternative and/or orthogonal systematic testing techniques include {\em iterative context bounding} (ICB) \cite{chess}, {\em dynamic interface reduction} (DIR) \cite{demeter}, {\em deterministic multithreading} (DMT) \cite{peregrine,dthreads,kendo,parrot}, {\em data race detection} \cite{eraser,tsan} and {\em state space estimation} \cite{estimation}.
We are presently developing {\em iterative deepening} (ID), a new orthogonal technique for automatically configuring subsets of preemption points (PPs) according to a fixed CPU budget, which has yet to be published.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Landslide \cite{landslide} is a systematic testing tool built with a focus on educational kernel architectures.
It is built as a module for Wind River Simics \cite{simics}, and supports testing Pebbles kernel code \cite{kspec}, userspace thread library code running on top of Pebbles \cite{thrlib}, and any userspace programs built on top of those.
Recently, we have also added support for testing Pintos kernels \cite{pintos} from schools such as Berkeley and U. Chicago; however in this project focused on the better-supported Pebbles environment.

C0 \cite{c0} is a C-like, type-safe educational programming language recently introduced for CMU's introductory CS curriculum.
It has recently been extended to support concurrent programming using a message-passing implementation known as channels.
These channels are defined by a {\tt choice}, a union-like protocol comprising multiple branches of possible message types, each with an expected payload and send/receive direction. Operations on these channels include sending and receiving, as well as forwarding, a way to join two channels of matching type together so messages automatically flow across them.

These channels' definitions and usage are type-checked at compile-time, so no type-safety violations (i.e. crashes), or even deadlocks, are possible -- at least, assuming the runtime implementation is correct. It is this implementation which we seek to verify in this paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Techniques}

The astute follower of our work will note that the advantages Landslide offers over the state-of-the-art seem ill-matched with the testing requirements of C0. The C0 runtime is a userspace program built on top of pthreads, so why jump through hoops to use a testing platform as heavyweight as Landslide, when tools like dBug exist that directly target the pthreads interface?

We chose Landslide because of its data-race analysis and iterative-deepening framework.
A type-safe concurrent language's runtime must necessarily contain some type-unsafe programming patterns, i.e., some manual sharing of state between threads outside the normal mutex/condvar primitives.
Even if all concurrent memory accesses end up being adequately protected by those primitives, we require instruction-level memory introspection to verify that property.
Landslide, which runs in a simulated environment and runs a data-race analysis on the fly, is ideal for this task, while the library-level interposition of dBug is too coarse-grained.
After identifying data race candidates, the iterative-deepening framework aids to manage multiple explorations to test interleavings around those accesses.


\subsection{Porting C0 to Pebbles}

Because the C0 concurrency runtime is implemented on top of the pthread interface, which Pebbles thread libraries, adapting it to run on top of a Pebbles kernel was a small task. The only missing functionality we needed to add was a {\tt thr\_detach()} implementation, requiring only about 10 lines of code. Apart from that, we stubbed out C0's file I/O and ncurses routines, as Pebbles does not provide system calls for those services.
The ported C0 libraries can be found at \url{https://github.com/bblum/landslide/tree/fp/pebsim/p2-basecode/user}.

\subsection{Improving Data Race Detection}

\definecolor{grey}{RGB}{127,127,127}
\definecolor{darkcyan}{RGB}{0,127,127}
\definecolor{olivegreen}{RGB}{0,127,0}
\definecolor{violet}{RGB}{127,0,127}
\definecolor{brickred}{RGB}{127,0,0}
\definecolor{brown}{RGB}{127,63,0}
\definecolor{orange}{RGB}{192,96,0}
\newcommand\hilight[2]{\color{#1}#2\color{black}}

\begin{figure}[h]
	\begin{subfigure}[b]{0.55\textwidth}
		\begin{center}
		\begin{tabular}{l|l}
			Thread 1 & Thread 2 \\
			\hline
			\begin{tabular}{l}
			\texttt{temp~=~malloc(...);} \\
			\texttt{\hilight{brickred}{temp->foo~=~bar;}} \\
			\\
			\texttt{mutex\_lock(...);} \\
			\texttt{\hilight{olivegreen}{global\_x~=~temp;}} \\
			\texttt{mutex\_unlock(...);} \\
			\end{tabular}
			& \\ &
			\begin{tabular}{l}
			\texttt{mutex\_lock(...);} \\
			\texttt{\hilight{olivegreen}{temp~=~global\_x;}} \\
			\texttt{mutex\_unlock(...);} \\
			\\
			\texttt{\hilight{brickred}{access(temp->foo);}} \\
			\end{tabular}
		\end{tabular}
		\end{center}
		\caption{Initialization false positive.}
		\label{fig:dra}
	\end{subfigure}
	\begin{subfigure}[b]{0.40\textwidth}
		\begin{center}
		\begin{tabular}{l|l}
			Thread 1 & Thread 2 \\
			\hline
			\\
			\begin{tabular}{l}
			\texttt{\hilight{brickred}{access(y->foo);}} \\
			\texttt{\hilight{olivegreen}{free(y);}} \\
			\end{tabular}
			& \\ &
			\begin{tabular}{l}
			{\em // malloc reuses y's} \\
			{\em // old address for z} \\
			\texttt{\hilight{olivegreen}{z~=~malloc(...);}} \\
			\texttt{\hilight{brickred}{z->foo~=~quux;}} \\
			\\
			\end{tabular}
		\end{tabular}
		\\
		\end{center}
		\caption{Free/re-malloc false positive.}
		\label{fig:drb}
	\end{subfigure}
	\caption{Example code patterns that produce false positive data race reports. In both cases, the accesses to the {\tt foo} field appear concurrent because the threads' transitions can be reordered, but in such a case, the value of the pointer dereferenced would change.}
	\label{fig:dr}
\end{figure}

In the course of making sure the new Landslide instrumentation worked correctly, we found two old problems with the data race (DR) detector that were exposed in testing C0 programs.
Both cases follow a "message sending" pattern, where while both threads are co-enabled, reordering the threads would cause them to access separate memory locations entirely.
This is because, although there is no concrete happens-before relation (from DPOR's perspective), a secondary pair of accesses elsewhere creates causality between the two primary accesses.
The two patterns are shown in Figure~\ref{fig:dr}, the primary access pair (the one falsely flagged as a DR) is coloured in \hilight{brickred}{red}, and the secondary pair is coloured in \hilight{olivegreen}{green}.

Originally, we thought we could suppress these false positives by classifying DR candidates as ``suspected'' or ``confirmed'', depending on whether we've observed them reordered. A DR being ``confirmed'' would indicate that the racy accesses truly can be interleaved at instruction granularity.
However, because Landslide's testing model involves allowing threads to run several shared memory accesses before being preempted, some suspected DRs may truly be bugs, yet impossible to confirm (i.e. reorder) without more fine-grained PPs.
In a systematic testing model where threads are preempted between all shared memory accesses, this suspected/confirmed method would work for soundly eliminating false positives.
Of course, part of Landslide's philosophy is to test state spaces without all PPs enabled, and the whole point of integrating DR detection with systematic testing is the figure out which subsets of memory accesses to preempt on to begin with. Hence the need for heuristically eliminating these false positives.

{\bf Initialization False Positives.} As shown in Figure~\ref{fig:dra}, one thread may locklessly initialize the fields of a shared data structure immediately after {\tt malloc}ing it, before publishing it to be visible to other threads. The second thread then accesses the global pointer under a lock, but then ``takes ownership'' of the pointed-to struct (e.g., by popping it off a linked list) and so does not need a lock during the dereference. If the threads were reordered, the locked access to the global pointer would return either {\tt NULL} or a different pointer instead.

The Eraser paper \cite{eraser} describes a heuristic for suppressing these DR reports by waiting until the memory is accessed by 2 threads, but this introduces the possibility of false negatives.
We think the best way of dealing with this problem is to incorporate a dataflow analysis, either static or dynamic, to track {\tt malloc}ed pointers and identify when they are first stored in a globally-visible location (i.e., not on the initializing thread's stack).
However, in Landslide we are taking a far simpler approach for now. We provide an annotation, {\tt ignore\_dr\_function}, to identify regions of code following this initialization pattern.

{\bf Free/Re-Malloc False Positives.} Figure~\ref{fig:drb} shows a similar pattern. Here, the variables each thread accesses are not even logically connected to the same data structure, and may not even be the same type. However, in the course of {\tt free}ing and {\tt malloc}ing memory, the same address is used in a later co-enabled thread transition. If the threads were reordered, {\tt malloc} would simply return a different heap chunk and the accesses would not collide. We fix these false positives as a special case by introducing a generation counter into our heap tracker module. Whenever a memory access is recorded for later data race analysis, the containing heap chunk's generation counter (if any) is stored as metadata, and later compared against the generation counters of other candidate accesses.

\subsection{Test Case Design}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evaluation}

evaluating stuff here



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

\bibliography{citations}{}
\bibliographystyle{alpha}
\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% vim: foldmethod=indent
