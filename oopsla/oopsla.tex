\documentclass[xcolor=dvipsnames]{beamer}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

\usepackage{manfnt}
\usepackage{wasysym}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{url}
\usepackage{ulem}
\usepackage{wasysym}
\usepackage{marvosym}
\usepackage{skull}
\usepackage{proof}
\usepackage{array}
\usepackage{colortbl}
\setbeamertemplate{navigation symbols}{}

\title[Quicksand]{{\bf Stateless Model Checking \\ with Data-Race Preemption Points}}
%\subtitle[]{CALCM group seminar}
\author[Ben Blum]{Ben Blum \texttt{(bblum@cs.cmu.edu)}}

\institute[]{Carnegie Mellon University \\ Pittsburgh, PA, USA}
\date[]{2016, November 03}

\setbeamertemplate{footline}{\hspace*{.5cm}\scriptsize{\insertauthor\hspace*{50pt} \hfill\insertframenumber\hspace*{.5cm}}} 

\usecolortheme{seahorse}
\usecolortheme{rose}
\useoutertheme{infolines}

\usecolortheme[named=ForestGreen]{structure}

\newcommand\noob{\mathsf{noob}}
\newcommand\gibs{\mathsf{gibs}}
\newcommand\dps{\mathsf{dps}}
\newcommand\squig\rightsquigarrow
\newcommand\Coloneqq{\mathrel{\mathop{::}}=}
\newcommand\dmg{\text{\Laserbeam}}
\newcommand\delter\delta
\newcommand\alpher\alpha
\newcommand\defnor{\text{ }|\text{ }}

\newcommand\pimp{\mathop{\supset}}
\newcommand\pand{\mathop{\wedge}}
\newcommand\por{\mathop{\vee}}
\newcommand\ptrue{\top}
\newcommand\pfalse{\bot}

\begin{document}
% TODO
\renewcommand{\inserttotalframenumber}{32}
\normalem
\begin{frame}
	\titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\linegap{\vspace{0.2in}}
\newcommand\breakslide[1]{\begin{frame}{} \begin{center} \Large #1 \end{center} \end{frame}}

\newcommand\hilight[2]{\color{#1}#2\color{black}}
\definecolor{olivegreen}{RGB}{0,127,0}
\definecolor{brickred}{RGB}{192,0,0}
\definecolor{orange}{RGB}{192,64,0}
\definecolor{blue}{RGB}{0,0,192}

\breakslide{Background: Stateless Model Checking}

\begin{frame}{Example}
	\begin{center}
	\begin{tabular}{ll}
		Initially \texttt{x = 0;} \\
		\\
		{\bf Thread 1} & {\bf Thread 2} \\
		\\
		\texttt{\hilight{orange}{mutex\_lock}(m);}	& \texttt{atomic\_xadd(\&x, 1);} \\
		\texttt{x++;}					& \texttt{\hilight{olivegreen}{yield}();} \\
		\texttt{\hilight{blue}{mutex\_unlock}(m);}	& \texttt{atomic\_xadd(\&x, 1);} \\
		\texttt{assert(x >= 1);}			& \texttt{assert(x >= 2);} \\
		\\
		\\
		\\
		\\
		\\
	\end{tabular}
	\end{center}
\end{frame}

\begin{frame}{Example}
	\begin{center}
	\begin{tabular}{ll}
		Initially \texttt{x = 0;} \\
		\\
		{\bf Thread 1} & {\bf Thread 2} \\
		\\
		\texttt{\hilight{orange}{mutex\_lock}(m);} \\
		\texttt{int tmp = x;} \\
								& \texttt{atomic\_xadd(\&x, 1);} \\
			`					& \texttt{\hilight{olivegreen}{yield}();} \\
								& \texttt{atomic\_xadd(\&x, 1);} \\
		\texttt{x = tmp + 1;} \\
								& \texttt{\hilight{red}{assert(x >= 2);}} \\
		\texttt{\hilight{blue}{mutex\_unlock}(m);} \\
		\texttt{assert(x >= 1);}
	\end{tabular}
	\end{center}
\end{frame}

\begin{frame}{Stateless Model Checking}
	Stateless Model Checking {\em [Godefroid '97]}
	\begin{itemize}
		\item Execution-based concurrency testing technique
		\item Test framework controls thread scheduling
		\item Each test iteration, test a different interleaving
		\item Goal: Exhaustively check all possible program behaviours
	\end{itemize}
	\pause
	\linegap

	\begin{center}
	\includegraphics[width=0.25\textwidth]{exponential-curve.pdf}
	\end{center}
\end{frame}
\begin{frame}{Stateless Model Checking}
	Stateless Model Checking {\em [Godefroid '97]}
	\begin{itemize}
		\item Execution-based concurrency testing technique
		\item Test framework controls thread scheduling
		\item Each test iteration, test a different interleaving
		\item Goal: Exhaustively check all possible program behaviours
	\end{itemize}
	\linegap

	Wait... {\em all possible} thread interleavings?
	\begin{itemize}
		\item Total verification may be feasible for ``small'' tests
		\item ``Large'' tests may have exponentially many possible schedules
		\item Completion depends on size of {\em state space}...
	\end{itemize}
	\linegap

	\vspace{2.975em} % ugh
\end{frame}

\begin{frame}{State Space Example}
	\begin{center}
		\includegraphics[width=0.96\textwidth]{tree-maximal-only.pdf}
	\end{center}
	\linegap

	Possible interleavings represented as a tree
	\begin{itemize}
		\item Node: Intermediate execution state 
		\item Edge: State transition from executing a thread
	\end{itemize}
\end{frame}

\begin{frame}{Preemption Points}
	The burning question: ``Which {\bf preemption points} (PPs) are important?''
	\linegap

	State space of interleavings is {\em parameterized} by PPs.
	\begin{itemize}
		\item Too few PPs: Many bugs will go undetected
		\item Preempt everywhere: Completion is often infeasible % say: "for some programs"
	\end{itemize}
	\linegap

	Prior model checkers hard-code a fixed set of PPs, committing to one state space in advance.
	% say: "...then attempt to cope with the resulting exponentially sized problem"
\end{frame}

\begin{frame}{Coping techniques}
	% Say "This is by no means an extensive list of related work
	Dynamic Partial Order Reduction (DPOR) {\em [Flanagan '05]}
	\begin{itemize}
		\item Identifies independent (commuting) transitions to prune
	\end{itemize}
	\pause
	\linegap

	Iterative Context Bounding (ICB) {\em [Musuvathi '08]}
	\begin{itemize}
		\item Heuristically orders search to prioritize fewer preemptions
	\end{itemize}
	\pause
	\linegap

	State space estimation {\em [Simsa '12]}
	\begin{itemize}
		\item Guesses completion time in advance based on existing progress
	\end{itemize}
	\pause
	\linegap

	Maximal Causality Reduction {\em [Huang '15]}
	\begin{itemize}
		\item Upgrades/replaces DPOR using constraint solving
	\end{itemize}
\end{frame}

\begin{frame}{Challenge}
	Given fixed PPs, testing time is unpredictable.
	\begin{itemize}
		\item Even small code changes can have drastic impact
		\item Choosing PPs statically makes tests infeasible, insufficient, or both!
	\end{itemize}
	\linegap

	{\bf Problem:} Make trade-off decision automatically.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\breakslide{Background: Data-Race Analysis}

\begin{frame}{Data-Race Analysis}
	\textbf{Data race:} 2 threads access the same memory, and...
	\begin{itemize}
		\item At least one access is a write
		\item Threads do not hold the same lock
		\item No {\em Happens-Before} relation between threads
	\end{itemize}
	\pause
	\linegap

	Variants of Happens-Before (HB)
	\begin{itemize}
		\item {\bf Pure HB:} Any synchronization events {\em [Lamport '78]}
			% Say: "Or another way of putting it I heard from one of yesterday's talks that I'm stealing, one event is guaranteed to be visible to the other"
			% Or don't, idgaf
		\item {\bf Limited HB:} Blocking synchronization (e.g. \texttt{cond\_wait()}) enforces one ordering {\em [O'Callahan '03]}
	\end{itemize}
\end{frame}

\begin{frame}{Happens-Before Example}
	\begin{center}
		\begin{tabular}{ll}
			{\bf Thread 1}	& {\bf Thread 2} \\
			\texttt{\hilight{red}{x++;}}	& \\
			\texttt{mutex\_lock(m);}	& \\
			\texttt{// unrelated}		& \\
			\texttt{mutex\_unlock(m);}	& \\
				& \texttt{mutex\_lock(m);} \\
				& \texttt{// unrelated} \\
				& \texttt{mutex\_unlock(m);} \\
				& \texttt{\hilight{red}{x++;}} \\
		\end{tabular}
		\linegap

		No race under Pure HB; {\em true potential race} under Limited HB.
	\end{center}
\end{frame}
\begin{frame}{Happens-Before Example}
	\begin{center}
		\begin{tabular}{ll}
			{\bf Thread 1}	& {\bf Thread 2} \\
			\texttt{\hilight{red}{x++;}}	& \\
			\texttt{mutex\_lock(m);}	& \\
			\texttt{\hilight{blue}{y = true;}}	& \\
			\texttt{mutex\_unlock(m);}	& \\
				& \texttt{mutex\_lock(m);} \\
				& \texttt{\hilight{blue}{bool tmp = y;}} \\
				& \texttt{mutex\_unlock(m);} \\
				& \texttt{\hilight{blue}{if (tmp)}~\hilight{red}{x++;}} \\
		\end{tabular}
		\linegap

		No race under Pure HB; {\em false positive} under Limited HB.
	\end{center}
\end{frame}

\begin{frame}{Races, Bugs, What's the Difference?}
	Not all data races lead to failures.
	\begin{itemize}
		\item C++ spec: All data races are undefined behaviour.
		\item Many prior tools: User attention is valuable, report only {\em failing} races. {\em [Engler '03, Kasicki '12]}
	\end{itemize}
	\linegap

	Stateless model checkers search for concrete, observable failures
	\begin{itemize}
		\item Assertion failures, memory errors, infinite loops
	\end{itemize}
	\linegap

	{\bf Problem:} Classify data races as {\em failing} or {\em benign}.
\end{frame}

\begin{frame}{Example (again)}
	\begin{center}
	\begin{tabular}{ll}
		Initially \texttt{x = 0;} \\
		\\
		{\bf Thread 1} & {\bf Thread 2} \\
		\\
		\texttt{\hilight{orange}{mutex\_lock}(m);} \\
		\texttt{int tmp = x;} \\
								& \texttt{atomic\_xadd(\&x, 1);} \\
			`					& \texttt{\hilight{olivegreen}{yield}();} \\
								& \texttt{atomic\_xadd(\&x, 1);} \\
		\texttt{x = tmp + 1;} \\
								& \texttt{\hilight{red}{assert(x >= 2);}} \\
		\texttt{\hilight{blue}{mutex\_unlock}(m);} \\
		\texttt{assert(x >= 1);}
	\end{tabular}
	\end{center}
\end{frame}

\begin{frame}{State Space (again)}
	\begin{center}
		\includegraphics[width=0.96\textwidth]{tree-maximal-only.pdf}
		\linegap

		None of these branches contain the necessary preemption!
		\linegap

		A {\bf data-race preemption point} is required to find the bug.
	\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\breakslide{Iterative Deepening and Quicksand}

\begin{frame}{Contribution}
	\textbf{Algorithm: Iterative Deepening}
	\begin{itemize}
		\item Seed model checker with synchronization API PPs;
		\item Dynamically detect new data-race candidates;
		\item Add data-race PPs as discovered;
		\item Iteratively advance to state spaces with new PPs;
		\item Prioritize them with dynamic state space estimates;
		\item ...until specified CPU budget is exhausted.
	\end{itemize}
\end{frame}

\begin{frame}{Iterative Deepening}
	``Minimal'' state space: mandatory thread switches only
	\begin{itemize}
		\item \texttt{yield()}, \texttt{cond\_wait()}, etc.
	\end{itemize}
	\linegap

	\begin{center}
		\includegraphics[width=0.3\textwidth]{tree0.pdf}
	\end{center}
\end{frame}

\begin{frame}{Iterative Deepening}
	Different PPs can produce state spaces of different sizes.
	\linegap

	Testing them in parallel hedges our bets.
	\linegap

	\begin{center}
		\includegraphics[width=0.48\textwidth]{tree1.pdf}
		\quad
		\includegraphics[width=0.48\textwidth]{tree2.pdf}
	\end{center}
\end{frame}

\begin{frame}{Iterative Deepening}
	If time allows, we combine PPs to produce larger tests.
	\linegap

	All PPs enabled = ``maximal'' state space
	\begin{itemize}
		\item Prior work tools explore this state space only.
	\end{itemize}
	\linegap

	\begin{center}
		\includegraphics[width=0.8\textwidth]{tree3.pdf}
	\end{center}
\end{frame}

\begin{frame}{Implementation}
	\textbf{Landslide} {\em [Blum '12]}, our simulator-based model checker
	\begin{itemize}
		\item Tests Pebbles thread libraries (CMU) and Pintos kernels (Berkeley, U. of Chicago, etc.)
		\item Wind River Simics provides instruction/memory-level tracing
		\item Features DPOR, estimation, ICB, and data-race detection
	\end{itemize}
	\linegap

	{\bf Quicksand}, our Iterative Deepening implementation
	\begin{itemize}
		\item Manages queue of {\em jobs} with different PP combinations
		\item A separate Landslide instance tests each job
		\item Prioritizes jobs based on state space estimates
	\end{itemize}
\end{frame}

\begin{frame}{System Architecture}
	\begin{center}
	\vspace{-0.88em}
	\includegraphics[width=0.86\textwidth]{dr-jobs-1.pdf}
	\end{center}
\end{frame}
\begin{frame}{System Architecture}
	\begin{center}
	\vspace{-0.88em}
	\includegraphics[width=0.86\textwidth]{dr-jobs-2.pdf}
	\end{center}
\end{frame}
\begin{frame}{System Architecture}
	\begin{center}
	\vspace{-0.88em}
	\includegraphics[width=0.86\textwidth]{dr-jobs-3.pdf}
	\end{center}
\end{frame}
\begin{frame}{System Architecture}
	\begin{center}
	\vspace{-0.88em}
	\includegraphics[width=0.86\textwidth]{dr-jobs-4.pdf}
	\end{center}
\end{frame}

\begin{frame}{Iterative Deepening Reductions}
	If one job is a subset of another, testing either might let us skip the other.
	% TODO
\end{frame}

\begin{frame}{Total Verification}
	\textbf{Convergence theorem:} Testing maximal state space, after detecting all data races, $\equiv$ preempting everywhere!
	\begin{itemize}
		\item Insight: $\forall$ arbitrary buggy interleaving, $\exists$ equivalent interleaving % say 'under DPOR' i guess?
			using only sync/data-race PPs.
	\end{itemize}
	\linegap

	Hence, Iterative Deepening provides ``best of both worlds'':
	\begin{itemize}
		\item Provides total safety guarantee for small tests
		\item Finds bugs quickly for large tests when completion is infeasible
	\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\breakslide{Evaluation}

\begin{frame}{Evaluation Questions}
	Comparing to single-state-space (SSS) testing
	\begin{itemize}
		\item Do we find more bugs given fixed CPU budgets?
		\item Do we provide more total verifications?
		\item ...whether or not SSS chooses PPs on synchronization only, or ``everywhere''?
	\end{itemize}
\end{frame}

\begin{frame}{Experimental Setup}
	Testing OS projects from CMU, Berkeley, and U. Chicago
	\begin{itemize}
		\item CMU: 79 ``Pebbles'' thread libraries ($\times$ 6 test cases each)
		\item Berkeley \& U. Chicago: 78 ``Pintos'' kernels ($\times$ 3 test cases each)
		\item 629 unique tests in total
	\end{itemize}
	\pause
	\linegap
	
	Experimental trials:
	\begin{itemize}
		\item Quicksand with Limited HB
		\item Quicksand with Pure HB
		\item SSS Landslide with ICB, mutex/yield PPs only
		\item SSS Landslide with ICB and ``Preempt Everywhere'' strategy
	\end{itemize}
	\pause
	\linegap

	629 tests $\times$ 10 CPU-hours $\times$ 4 trials $\approx$ 1000 CPU-days
\end{frame}

\begin{frame}{Results (Bug-finding, CPU time)}
	\begin{center}
	\vspace{-0.8em}
	\includegraphics[width=0.87\textwidth]{bugs-talk.pdf}
	\end{center}
\end{frame}
\begin{frame}{Results (Bug-finding, wall-clock time)}
	\begin{center}
	\vspace{-0.8em}
	\includegraphics[width=0.87\textwidth]{bugs-wallclock-talk.pdf}
	\end{center}
\end{frame}
\begin{frame}{Results (Verification, CPU time)}
	\begin{center}
	\vspace{-0.8em}
	\includegraphics[width=0.87\textwidth]{verifs-talk.pdf}
	\end{center}
\end{frame}

\begin{frame}{Takeaway}
	Quicksand outperforms SSS after 10 CPU-hours in all cases.
	\begin{itemize}
		\item 108\%-125\% as many bugs found
		\item 336\%-428\% as many verifications provided
	\end{itemize}
	\linegap

	``Preempt Everywhere'' finds bugs best for SSS, but overhead of PPs significantly impacts completion time.
	\linegap

	Pure HB provides more verifications; when possible; \\
	Limited HB finds more bugs, at expense of completion time.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\breakslide{Thanks \& Questions}

\breakslide{Bonus Slides}

\begin{frame}{More Statistics about our Test Suite}
	Bugs by required number of preemptions to expose:
	\begin{center}
        	\footnotesize
        \begin{tabular}{r|c|c}
                {\bf Bound} & {\bf SSS-MC-ICB} & {\bf SSS-MC-Shared-Mem} \\
                \hline
                0       & 2     & 1     \\  
                1       & 82    & 86    \\  
                2       & 16        & 32    \\  
                3       & 2     & 3     \\  
                4+      & 0     & 0     \\  
                \hline
                Total   & 102       & 122   \\  
        \end{tabular}
	\end{center}
	\linegap
	
	Bugs by type (Limited HB trial):
	% Not actually complete, sorry. I didn't run "getbugtype" on all of the 153 bugs.
	% Also some of them had multiple bug types and I am including those here.
	% This is what you can see on the publically available spreadsheet.
	\begin{itemize}
		\item 45 heap errors (43 use-after-free, 2 other)
		\item 32 page fault crashes %(11 kernel, 21 userspace)
		\item 26 assertion failures %(21 kernel, 5 userspace)
		\item 21 deadlocks
		\item 2 infinite loops
		\item 1 recursive mutex lock
	\end{itemize}
\end{frame}

\begin{frame}{Results (``Nondeterministic'' Data Races)}
	\begin{center}
		\vspace{-0.8em}
	\includegraphics[width=0.88\textwidth]{dr-false-negatives-poster.pdf}
	\end{center}
\end{frame}

\begin{frame}{DPOR Example}
	\begin{center}
		\includegraphics[width=\textwidth]{undiamond1.png}
	\end{center}
\end{frame}

\begin{frame}{References}
	\scriptsize
	\begin{itemize}
		\item {\bf [Lamport '78]}: 
			Leslie Lamport. Time, clocks, and the ordering of events in a distributed system.
			Commun. ACM, 1978.
		\item {\bf [Godefroid '97]}: Patrice Godefroid.
			VeriSoft. A tool for the automatic analysis of concurrent reactive software. CAV 1997.
		\item {\bf [Engler '03]}: Dawson Engler and Ken Ashcraft. 
			RacerX: effective, static detection of race conditions and deadlocks. SOSP 2003.
		\item {\bf [O'Callahan '03]}: Robert O'Callahan and Jong-Deok Choi.
			Hybrid dynamic data race detection. PPoPP '03.
		\item {\bf [Flanagan '05]}: Cormac Flanagan and Patrice Godefroid. Dynamic partial-order reduction for
			model checking software. POPL 2005.
		\item {\bf [Musuvathi '08]}: Madanlal Musuvathi et al. Finding and Reproducing Heisenbugs in Concurrent
			Programs. OSDI 2008.
		\item {\bf [Simsa '12]}: Jiri Simsa. Runtime Estimation and Resource Allocation for
			Concurrency Testing. CMU-PDL-12-113. December 2012.
		\item {\bf [Blum '12]}: Ben Blum. Landslide: Systematic Dynamic Race Detection in Kernel
			Space. CMU-CS-12-118. May 2012.
		\item {\bf [Kasicki '12]}: Baris Kasicki. Data races vs. data race bugs: telling the difference with Portend. ASPLOS '12.
		\item {\bf [Huang '15]}: Jeff Huang. Stateless model checking concurrent programs with maximal causality reduction. PLDI '15.

	\end{itemize}
\end{frame}


\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{frame}{Outline}
%	\textbf{Background}
%	\begin{itemize}
%		\item Preemption points
%		\item Stateless model checking (aka, systematic testing)
%		\item Data races
%	\end{itemize}
%	{\bf Quicksand \& Iterative Deepening}
%	\begin{itemize}
%		\item State space estimation
%		\item Data-race preemption points
%		\item Implementation with Landslide
%	\end{itemize}
%	{\bf Evaluation}
%	\begin{itemize}
%		\item Comparison to ``single-state-space'' approach
%		\item Nondeterministic data-race candidates
%		\item Providing total verification
%	\end{itemize}
%\end{frame}
%
%
%\section{Introduction}
%
%\subsection{Stateless Model Checking}
%\definecolor{thread1}{RGB}{87,172,255}
%\definecolor{thread2}{RGB}{255,201,102}
%\definecolor{thread3}{RGB}{255,128,160}
%
%\begin{frame}{Case Study}
%	\begin{center}
%		\begin{tabular}{llll}
%			\fbox{
%			\begin{tabular}{l}
%				Consumer thread \\
%				\hline
%				\\
%				\texttt{mutex\_lock(mx);} \\
%				\\
%				\texttt{if~(!work\_exists())} \\
%				\texttt{~~~~cond\_wait(cvar,~mx);} \\
%				\texttt{work~=~dequeue();} \\
%				\\
%				\texttt{mutex\_unlock(mx);} \\
%				\texttt{access(work->data);} \\
%			\end{tabular}
%			}
%			& & &
%			\fbox{
%			\begin{tabular}{l}
%				Producer thread \\
%				\hline
%				\\
%				\texttt{mutex\_lock(mx);} \\
%				\\
%				\texttt{enqueue(work);} \\
%				\texttt{signal(cvar);} \\
%				\\
%				\texttt{mutex\_unlock(mx);} \\
%				\\
%				\\
%			\end{tabular}
%			}
%		\end{tabular}
%		\linegap
%
%		\begin{itemize}
%			%\item See {\bf Paradise Lost} lecture!
%			\item {\tt if} vs {\tt while}: Two consumers can interleave to make one fail.
%		\end{itemize}
%	\end{center}
%\end{frame}
%\begin{frame}{Thread Interleavings (``good'' case)}
%	\begin{center}
%		\begin{tabular}{|l|l|l|}
%			\hline
%			\cellcolor{thread1} {\bf Thread 1} & \cellcolor{thread2} {\bf Thread 2} & \cellcolor{thread3} {\bf Thread 3} \\
%			\hline
%			\small \texttt{lock(mx);} & & \\
%			\small \texttt{if~(!work\_exists())} & & \\
%			\small \texttt{~~~~wait(cvar,~mx);} & & \\
%			
%			& & \small \texttt{lock(mx);} \\
%			& & \small \texttt{if~(!work\_exists())} \\
%			& & \small \texttt{~~~~wait(cvar,~mx);} \\
%
%			& \small \texttt{lock(mx);} & \\
%			& \small \texttt{enqueue(work);} & \\
%			& \small \texttt{signal(cvar);} & \\
%			& \small \texttt{unlock(mx);} & \\
%			
%			\small \texttt{work~=~dequeue();~} & & \\
%			\small \texttt{unlock(mx);} & & \\
%			\small \texttt{access(work->data);}& & \\
%			\hline
%		\end{tabular}
%	\end{center}
%\end{frame}
%\begin{frame}{Thread Interleavings (different ``good'' case)}
%	\begin{center}
%		\begin{tabular}{|l|l|l|}
%			\hline
%			\cellcolor{thread1} {\bf Thread 1} & \cellcolor{thread2} {\bf Thread 2} & \cellcolor{thread3} {\bf Thread 3} \\
%			\hline
%			\small \texttt{lock(mx);} & & \\
%			\small \texttt{if~(!work\_exists())} & & \\
%			\small \texttt{~~~~wait(cvar,~mx);} & & \\
%			
%			& \small \texttt{lock(mx);} & \\
%			& \small \texttt{enqueue(work);} & \\
%			& \small \texttt{signal(cvar);} & \\
%			& \small \texttt{unlock(mx);} & \\
%			
%			\small \texttt{work~=~dequeue();~} & & \\
%			\small \texttt{unlock(mx);} & & \\
%			\small \texttt{access(work->data);}& & \\
%			
%			& & \small \texttt{lock(mx);} \\
%			& & \small \texttt{if~(!work\_exists())} \\
%			& & \small \texttt{~~~~wait(cvar,~mx);} \\
%			\hline
%		\end{tabular}
%	\end{center}
%\end{frame}
%\begin{frame}{Thread Interleavings (race condition)}
%	\begin{center}
%		\begin{tabular}{|l|l|l|}
%			\hline
%			\cellcolor{thread1} {\bf Thread 1} & \cellcolor{thread2} {\bf Thread 2} & \cellcolor{thread3} {\bf Thread 3} \\
%			\hline
%			\small \texttt{lock(mx);} & & \\
%			\small \texttt{if~(!work\_exists())} & & \\
%			\small \texttt{~~~~wait(cvar,~mx);} & & \\
%			
%			& \small \texttt{lock(mx);} & \\
%			& \small \texttt{enqueue(work);} & \\
%			& \small \texttt{signal(cvar);} & \\
%			& \small \texttt{unlock(mx);} & \\
%			
%			& & \small \texttt{lock(mx);} \\
%			& & \small \texttt{work~=~dequeue();~~} \\
%			& & \small \texttt{unlock(mx);} \\
%
%			\small \texttt{work~=~dequeue();} & & \\
%			\small \texttt{unlock(mx);} & & \\
%			\small \texttt{//~SIGSEGV} {\large \frownie}& & \\
%			\hline
%		\end{tabular}
%	\end{center}
%\end{frame}
%
%\newcommand\related[1]{\textsuperscript{\em [#1]}}
%
%
%\begin{frame}{Motivating Stateless Model Checking}
%	Goal: Test as many interleavings as you can (given some CPU budget)
%	\linegap
%
%	\textbf{Stress testing}
%	\begin{itemize}
%		\item Relies on randomly-occurring timer (or I/O) interrupts
%			% to perturb threads
%		\item Exposes nondeterministic bugs at random
%		\item Might not find bugs in any bounded time
%	\end{itemize}
%	\linegap
%
%	\textbf{Stateless Model Checking} (MC)\related{Godefroid '97}
%	\begin{itemize}
%		\item Exhaustively exercise {\em all} thread interleavings
%		\begin{itemize}
%			\item ...around a given set of {\em preemption points}
%		\end{itemize}
%		\item Identify bugs for certain (e.g. segfault, deadlock, panic)
%		\item More reliable coverage, better reproducibility
%		\item Exponentially-sized state space of interleavings
%			%depending on \# of preemption points
%	\end{itemize}
%	%Moving beyond stress testing: which {\em preemption points} are important?
%\end{frame}
%
%\begin{frame}{Preemption Points}
%	\textbf{Preemption points} (PPs) are program locations where a context switch might expose different behaviour.
%	\linegap
%
%	Stateless MC is {\em parameterized} by which PPs can trigger thread switches.
%	\linegap
%
%	For case study, {\tt mutex\_lock}, {\tt mutex\_unlock}, {\tt cond\_wait} are relevant.
%	\pause
%	\linegap
%
%	Which PPs to use?
%	\begin{itemize}
%		\item Every instruction (exhaustive, but intractable)
%		\item Synchronization API calls\related{Musuvathi '08, Simsa '10, Blum '12}
%		%\item Kernel mutex interface\related{Blum '12}
%		\item Global/heap memory accesses\related{Holzmann '97, Yang '08}
%	\end{itemize}
%\end{frame}
%
%\begin{frame}{MC State of the Art}{(my new DJ name?)}
%	Modern stateless MC tools can {\em mitigate} exponential explosion.
%	\begin{itemize}
%		\item Dynamic Partial Order Reduction (DPOR)\related{Flanagan '05}
%		\item State space estimation\related{Simsa '12}
%	\end{itemize}
%	\linegap
%
%	However, existing MCs ``hard-code'' their PPs in advance.
%	\begin{itemize}
%		\item With too many preemption points, tests time out.
%		\item Which PPs are ``good'' differs for each test case.
%		\item Relationship between PPs and testing time is unpredictable.
%	\end{itemize}
%	\linegap
%
%	Current MC model is not user-friendly.
%	\begin{itemize}
%		\item Tool: ``I want to use these PPs, but can't predict completion time.''
%		\item User: ``I have 16 CPUs and 24 hours to test my program.''
%	\end{itemize}
%\end{frame}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsection{Data Races}
%
%\begin{frame}{Data Races\related{Savage '97}}
%	A {\bf data race} is a pair of memory accesses between two threads, where:
%	\begin{itemize}
%		\item At least one of the accesses is a write
%		\item The threads are not holding the same mutex
%		%\item The threads can be reordered (e.g., no \texttt{cond\_signal()} in between)
%		\item The threads' executions are not related by {\em Happens-Before}
%	\end{itemize}
%
%	Data races are {\em not necessarily} bugs, just highly suspicious!
%	\begin{itemize}
%		\item ``If threads interleaved the wrong way here, it {\em might} crash later.''
%		\item Hence, data race locations are ideal PP candidates.
%	\end{itemize}
%\end{frame}
%
%\begin{frame}{The Happens-Before (HB) Relation}
%	Most data-race analyses use {\em Pure HB} to determine simultaneity.
%	\begin{itemize}
%		\item HB is established by any synchronization (mutexes, cvars, xchg...)
%		\item Represents possiblity of threads' behaviour to change if reordered
%			%\begin{itemize}
%			%	\item ...that the programmers obviously intended.
%			%\end{itemize}
%		\item May exclude some races from alternate interleavings ({\em false negatives})
%	\end{itemize}
%	\pause
%	\linegap
%
%	To avoid false negatives, we use {\em Limited HB}\related{O'Callahan '03} instead.
%	%, Serebryany '09}
%	\begin{itemize}
%		\item HB is established only when thread runnability changes (cvars).
%		\item Represents ability to reorder accesses to occur simultaneously
%		\item Captures accesses separated by unrelated, synchronized, logic
%		\item Will also falsely flag some {\em false positives}
%		\item Combined with lock-set analysis to increase accuracy
%	\end{itemize}
%\end{frame}
%
%
%\begin{frame}{Happens-Before Example}
%	\begin{center}
%		\begin{tabular}{|l|l|}
%			\hline
%			\cellcolor{thread1} {\bf Thread 1} & \cellcolor{thread2} {\bf Thread 2} \\
%			\hline
%			& \\
%			\small \texttt{x++;} // A & \\
%			\small \texttt{lock(mx);} & \\
%			%\small \texttt{y = true;} & \\
%			\small \texttt{unlock(mx);} & \\
%			
%			& \\
%			& \small \texttt{lock(mx);} \\
%			& \small \texttt{unlock(mx);} \\
%			& \small \texttt{x++;} // B \\
%			& \\
%			\hline
%		\end{tabular}
%	\end{center}
%	{\bf Pure HB}: \texttt{mx} establishes $HB(A, B)$; no race reported (false negative).
%	\linegap
%
%	{\bf Limited HB}: $\neg HB(A, B)$; race is reported (correctly).
%\end{frame}
%
%\begin{frame}{Happens-Before Example}
%	\begin{center}
%		\begin{tabular}{|l|l|}
%			\hline
%			\cellcolor{thread1} {\bf Thread 1} & \cellcolor{thread2} {\bf Thread 2} \\
%			\hline
%			\small \texttt{x++;} // A & \\
%			\small \texttt{lock(mx);} & \\
%			\small \texttt{y = true;} & \\
%			\small \texttt{unlock(mx);} & \\
%			
%			& \small \texttt{lock(mx);} \\
%			& \small \texttt{bool z = y;} \\
%			& \small \texttt{unlock(mx);} \\
%			& \small \texttt{if (z);} \\
%			& \small \texttt{~~x++;} // B \\
%			\hline
%		\end{tabular}
%	\end{center}
%	{\bf Pure HB}: \texttt{mx} establishes $HB(A, B)$; no race reported (correctly).
%	\linegap
%
%	{\bf Limited HB}: $\neg HB(A, B)$; race is reported (false positive).
%\end{frame}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\breakslide{\Huge Quicksand}
%
%\begin{frame}{Iterative Deepening of Preemption Points}
%	Goal: Run the best tests for a given CPU budget.
%	\linegap
%
%	Inspired by past experience with Landslide, our MC tool\related{Blum '12}
%	\begin{itemize}
%		\item 15-410 student volunteers worked best with iterative process
%		\item ``Start small, then add more preemption points as time allows''
%		\item Quicksand now automates this via {\em Iterative Deepening}
%	\end{itemize}
%	\linegap
%
%	Named after analogous technique in chess AI.
%	\begin{itemize}
%		\item Chess search is DFS limited by max number of moves (ply).
%		\item Chess AIs repeat DFS, increasing ply, until timeout.
%	\end{itemize}
%\end{frame}
%
%\begin{frame}{Iterative Deepening in Quicksand}
%	Quicksand automatically iterates through different configurations of PPs.
%	\begin{itemize}
%		\item Manages work queue of jobs with different PPs
%		\item Each job represents a new state space for Landslide to explore
%		\item Prioritizes jobs based on estimated completion time
%		%\item Prioritizes which jobs are important / likely to finish
%		%\begin{itemize}
%		%	\item Based on nature of PPs (data races? mutexes?)
%		%	\item Based on estimated completion time
%		%\end{itemize}
%		\item New PPs added on-the-fly from data-race analysis
%	\end{itemize}
%	\linegap
%
%	Repeat state space explorations, adding preemption points, until time is exhausted.
%
%	\linegap
%	{\em Only required argument is CPU budget}
%\end{frame}
%
%\begin{frame}{Iterative Deepening}
%	Minimal state space includes only ``mandatory'' context switches
%	\begin{itemize}
%		\item e.g., {\tt yield()}, {\tt cond\_wait()}.
%		% Say: When the test invokes yield, the kernel scheduler will pick
%		% one thread to run next. With Landslide, we will pick ALL threads to
%		% run next, in one parallel universe at a time.
%	\end{itemize}
%	\vspace{0.29in}
%	\begin{center}
%		\includegraphics[width=0.35\textwidth]{tree0.pdf}
%	\end{center}
%\end{frame}
%
%\begin{frame}{Iterative Deepening}
%	Adding different PPs can produce state spaces of different sizes; Quicksand tries them in parallel, as informed by state space estimation\related{Simsa '12}.
%	\vspace{0.15in}
%	\begin{center}
%		\begin{tabular}{cc}
%			\includegraphics[width=0.45\textwidth]{tree1.pdf} &
%			\includegraphics[width=0.5\textwidth]{tree2.pdf}
%		\end{tabular}
%	\end{center}
%\end{frame}
%
%
%\begin{frame}{Iterative Deepening}
%	If time allows, combine PPs into larger, more comprehensive state spaces.
%	\linegap
%
%	All PPs enabled = ``maximal'' state space
%	\begin{itemize}
%		\item Prior work tools test this state space only.
%	\end{itemize}
%	%eventually converging to using all PPs at once ({\em ``maximal'' state space}).
%	\begin{center}
%		\includegraphics[width=0.8\textwidth]{tree3.pdf}
%	\end{center}
%	% say: and depending on your time budget, you might decide that you expect this one to be feasible, or you might fall back to a smaller state space from before.
%\end{frame}
%
%\begin{frame}{Total Verification}
%	% Let's come back to this issue of ...
%	MC can {\em totally verify} a test by testing a state space with all possible PPs.
%	\begin{itemize}
%		\item Ordinarily infeasible, but some tests are small enough
%		%\item Whether a test can be totally verified can't be known in advance.
%		\item ``Hard-coded'' PP approach\related{Musuvathi '08} sacrifices this possibility.
%	%One downside of hard-coding PPs in advance is timing out when the test is too large, but another downside is if the test is small enough, you might miss a possible full verification!
%		\item What PP strategy works for both small and large tests?
%	\end{itemize}
%	\pause
%	\linegap
%
%	Synchronization API PPs \& data-race PPs are sufficient!
%	\begin{itemize}
%		\item {\bf Theorem (Convergence)}:
%			{\em If a bug can be exposed by any thread interleaving
%				possible by preempting on all instructions,
%				% during a specific test
%			Quicksand will eventually test an equivalent interleaving which exposes the same bug.}
%		\item Proof appeals to DPOR soundness\related{Flanagan '05} and Limited HB.
%		\item Intuition: ``Adding data-race PPs until saturation = all possible thread communication points.''
%	\end{itemize}
%\end{frame}
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\section{Evaluation}
%
%\breakslide{\Huge Evaluation}
%
%\begin{frame}{Evaluation}
%	Evaluation questions:
%	\begin{enumerate}
%		\item Do we find more bugs than prior MC with data-race PPs?
%		\item Do we find bugs faster than prior MC, even without data-race PPs?
%			% say: "the same bugs"
%		\item Does MC uncover new, nondeterministic, data-race candidates?
%		\item Do we provide more total verifications than prior MC?
%	\end{enumerate}
%\end{frame}
%
%\begin{frame}{Experimental Setup}
%	\textbf{Test suite}: 79 ``P2''s $\times$ 6 test cases + 78 ``Pintos''s $\times$ 3 test cases
%	\begin{itemize}
%		\item P2: CMU 15-410 thread library project (\textasciitilde{}1800 LOC)
%		\item Pintos: Berkeley CS162/U. Chicago CS320 kernel project (\textasciitilde{}700 LOC)
%		\item 629 unique state spaces (i.e., project/test pairs)
%	\end{itemize}
%\end{frame}
%\begin{frame}{Experimental Setup}
%	\textbf{Quicksand experiment}: 1 hour $\times$ 10 CPUs per test
%	\begin{itemize}
%		\item {\bf QS}: Data-race PPs enabled
%		\item {\bf QS-no-DRs}: Restrict iterative deepening to sync API PPs only
%	\end{itemize}
%	\linegap
%
%	{\bf Control experiment}: 10 hours $\times$ 1 CPU per test
%	\begin{itemize}
%		\item Test only ``maximal`` state space, using all sync API PPs at once
%		\item {\bf DPOR}: Use DPOR\related{Flanagan '05} to test maximal space in single pass
%		\item {\bf ICB}: Use Iterative Context Bounding\related{Musuvathi '07, Coons '13} to repeatedly test maximal space with increasing preemption bound
%			% dont mention BPOR
%	\end{itemize}
%\end{frame}
%
%\begin{frame}{1. Finding more bugs with data-race PPs}
%	\begin{center}
%		\includegraphics[width=0.6\textwidth]{eval1.pdf}
%	\end{center}
%	\begin{itemize}
%		\item 17-118 seconds: Quicksand loses on parallelization/startup overhead
%			%\begin{itemize}
%			%	\item (remember: Quicksand on 10 CPUs, control on 1)
%			%\end{itemize}
%		\item Ultimately, 180\% as many bugs in total!
%	\end{itemize}
%\end{frame}
%
%\begin{frame}{2. Finding the same bugs... slower}
%	\begin{center}
%		\includegraphics[width=0.6\textwidth]{eval2.pdf}
%	\end{center}
%	\begin{itemize}
%		\item ICB outperforms Iterative Deepening when using the same PPs
%		\item Suggests Quicksand could incorporate ICB in its scheduling strategy
%	\end{itemize}
%\end{frame}
%
%\begin{frame}{3. Nondeterministic data-race candidates}
%	Some data races come from code that executes only nondeterministically.
%	\begin{itemize}
%		\item In a single-execution data race analysis, these accesses won't be seen.
%		\item MC can uncover the racy logic, identify a new PP, and find more bugs.
%	\end{itemize}
%
%	\begin{center}
%		\includegraphics[width=0.7\textwidth]{eval3.pdf}
%	\end{center}
%\end{frame}
%
%\begin{frame}{4. Total verification}
%	\begin{center}
%		\includegraphics[width=0.6\textwidth]{eval4.pdf}
%	\end{center}
%	\begin{itemize}
%		\item If no data-race candidates, can verify with sync API PPs alone.
%		\item Data-race PPs allow total verification of 425\% as many tests!
%		\item ICB slower to verify than single-pass DPOR due to repeated work.
%	\end{itemize}
%\end{frame}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\section{End}
%\breakslide{\Huge Conclusion}
%
%\begin{frame}{Conclusion}
%	Stateless Model Checking depends on good {\bf preemption points} (PPs).
%	\linegap
%
%	MC State of the Art chooses a fixed PP set in advance.
%	\linegap
%
%	Quicksand schedules multiple tests, with different PPs, in parallel.
%	\begin{itemize}
%		\item Iterative Deepening incorporates new data-race PPs on-the-fly
%		\item Data race PPs uncover {\bf 80\% more bugs} than sync API PPs alone
%		\item Data race PPs enable {\bf total verification} when test is small enough
%	\end{itemize}
%	\linegap
%
%	OOPSLA submission soon; looking for feedback!
%\end{frame}
%
%\breakslide{\Large Questions?
%\linegap
%
%\begin{center}
%	\includegraphics[width=0.65\textwidth]{3word-questions.png}
%\end{center}}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\section{Bonus Slides}

